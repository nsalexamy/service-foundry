<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Presenter Scripts: Using Kustomize With Helm Charts for Argo CD Applications</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        body {
            font-family: sans-serif;
            background-color: #f8fafc;
            color: #1f2937;
            margin: 0;
            padding: 0;
        }
    </style>
    
</head>
<body>
<div id="toc" class="toc">
<div id="toctitle">On this page</div>
<ul class="sectlevel1">
<li><a href="#introduction-script">Introduction Script</a></li>
<li><a href="#section-1-the-challenge">Section 1: The Challenge</a></li>
<li><a href="#section-2-the-better-way">Section 2: The Better Way</a></li>
<li><a href="#section-3-understanding-values-files">Section 3: Understanding Values Files</a></li>
<li><a href="#section-4-understanding-overlays">Section 4: Understanding Overlays</a></li>
<li><a href="#section-5-installing-kustomize">Section 5: Installing Kustomize</a></li>
<li><a href="#section-6-directory-structure-walkthrough">Section 6: Directory Structure Walkthrough</a></li>
<li><a href="#section-7-dev-environment-configuration">Section 7: Dev Environment Configuration</a></li>
<li><a href="#section-8-helm-values-explained">Section 8: Helm Values Explained</a></li>
<li><a href="#section-9-testing-locally">Section 9: Testing Locally</a></li>
<li><a href="#section-10-argo-cd-application">Section 10: Argo CD Application</a></li>
<li><a href="#section-11-benefits-recap">Section 11: Benefits Recap</a></li>
<li><a href="#section-12-troubleshooting-the-enable-helm-error">Section 12: Troubleshooting the Enable-Helm Error</a></li>
<li><a href="#section-13-scaling-to-multiple-environments">Section 13: Scaling to Multiple Environments</a></li>
<li><a href="#section-14-applicationset-configuration">Section 14: ApplicationSet Configuration</a></li>
<li><a href="#section-15-why-use-applicationset">Section 15: Why Use ApplicationSet</a></li>
<li><a href="#section-16-securing-secrets">Section 16: Securing Secrets</a></li>
<li><a href="#section-17-creating-sealed-secrets">Section 17: Creating Sealed Secrets</a></li>
<li><a href="#section-18-putting-it-all-together">Section 18: Putting It All Together</a></li>
<li><a href="#conclusion-script">Conclusion Script</a></li>
<li><a href="#video-production-notes">Video Production Notes</a>
<ul class="sectlevel2">
<li><a href="#suggested-video-structure">Suggested Video Structure</a></li>
<li><a href="#screen-recording-suggestions">Screen Recording Suggestions</a></li>
<li><a href="#voiceover-tips">Voiceover Tips</a></li>
</ul>
</li>
<li><a href="#youtube-publishing-content">YouTube Publishing Content</a>
<ul class="sectlevel2">
<li><a href="#video-title">Video Title</a></li>
<li><a href="#video-description">Video Description</a></li>
<li><a href="#youtube-tags">YouTube Tags</a></li>
</ul>
</li>
<li><a href="#linkedin-publishing-content">LinkedIn Publishing Content</a>
<ul class="sectlevel2">
<li><a href="#article-title">Article Title</a></li>
<li><a href="#linkedin-summary">LinkedIn Summary</a></li>
<li><a href="#linkedin-article-opening-hook">LinkedIn Article Opening Hook</a></li>
<li><a href="#linkedin-hashtags-optimized-set">LinkedIn Hashtags (Optimized Set)</a></li>
<li><a href="#linkedin-posting-strategy">LinkedIn Posting Strategy</a></li>
<li><a href="#linkedin-article-tags-backend">LinkedIn Article Tags (Backend)</a></li>
</ul>
</li>
<li><a href="#social-media-promotion-plan">Social Media Promotion Plan</a>
<ul class="sectlevel2">
<li><a href="#twitterx-thread-7-tweets">Twitter/X Thread (7 tweets)</a></li>
<li><a href="#reddit-posts">Reddit Posts</a></li>
<li><a href="#dev-to-post-excerpt">Dev.to Post Excerpt</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="introduction-script">Introduction Script</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Hello and welcome! In this video, we&#8217;re going to explore how to combine two powerful Kubernetes tools, Kustomize and Helm, to manage your applications across multiple environments using GitOps principles with Argo CD.</p>
</div>
<div class="paragraph">
<p>If you&#8217;ve ever struggled with managing different configurations for development, staging, and production environments, or found yourself copying and pasting Helm values files everywhere, this video is for you.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll use PostgreSQL as our example application, but the patterns you&#8217;ll learn can be applied to any Helm chart you want to deploy.</p>
</div>
<div class="paragraph">
<p>By the end of this video, you&#8217;ll understand why combining Kustomize and Helm makes sense, how to structure your Git repository for multi-environment deployments, how to configure Argo CD to work with both tools, and how to securely manage secrets using Sealed Secrets.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s get started!</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-1-the-challenge">Section 1: The Challenge</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Let&#8217;s start by talking about the challenge we&#8217;re trying to solve.</p>
</div>
<div class="paragraph">
<p>When deploying Helm charts with Argo CD, the typical approach is to embed your values directly in the Argo CD Application manifest or use inline overrides. While this works fine for simple, single-environment setups, it quickly becomes a pain as you scale.</p>
</div>
<div class="paragraph">
<p>Here are the problems you&#8217;ll face.</p>
</div>
<div class="paragraph">
<p>First, tight coupling. Your configuration values are embedded directly in the Argo CD Application definition, making it hard to separate concerns.</p>
</div>
<div class="paragraph">
<p>Second, poor reusability. It becomes difficult to use the same Helm chart across development, staging, and production environments.</p>
</div>
<div class="paragraph">
<p>Third, version control becomes a mess. Different values files are scattered across multiple Application manifests, making it hard to track changes.</p>
</div>
<div class="paragraph">
<p>Fourth, changes are difficult to review. When you modify values, those changes get mixed with application configuration changes, making pull requests confusing.</p>
</div>
<div class="paragraph">
<p>And fifth, there&#8217;s no clear promotion path. How do you promote changes from development to staging to production in a controlled way?</p>
</div>
<div class="paragraph">
<p>These problems add up quickly as your infrastructure grows.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-2-the-better-way">Section 2: The Better Way</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>So what&#8217;s the better approach? By introducing Kustomize as a layer between Argo CD and Helm, you gain several important benefits.</p>
</div>
<div class="paragraph">
<p>First, clean separation. Each environment gets its own directory with its own values file. Everything is organized and easy to find.</p>
</div>
<div class="paragraph">
<p>Second, reusability. You use the same Helm chart, just pointing to different values files for each environment.</p>
</div>
<div class="paragraph">
<p>Third, GitOps-friendly structure. All configuration lives in Git with a clear directory structure that makes sense.</p>
</div>
<div class="paragraph">
<p>Fourth, easy promotion. You can copy or merge changes between environment directories using standard Git workflows.</p>
</div>
<div class="paragraph">
<p>And fifth, better code reviews. Git diffs clearly show what changed for each environment, making pull request reviews much easier.</p>
</div>
<div class="paragraph">
<p>Think of Kustomize as the organizer for your Helm charts. It allows you to maintain environment-specific configurations in a structured, maintainable way.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-3-understanding-values-files">Section 3: Understanding Values Files</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Before we dive into the implementation, there are two important concepts you need to understand about how Kustomize and Helm work together.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s talk about values files first.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s something important to know. Unlike the Helm command-line interface, which lets you merge multiple values files together, Kustomize&#8217;s values file property does NOT support merging.</p>
</div>
<div class="paragraph">
<p>This means each environment&#8217;s values file must contain all the values you want to customize, both common settings and environment-specific settings.</p>
</div>
<div class="paragraph">
<p>You have two options here.</p>
</div>
<div class="paragraph">
<p>Option one is to keep complete values in each environment&#8217;s file. This is the recommended approach. You include all configuration, both common and environment-specific, in files like values-dev.yaml, values-staging.yaml, and values-prod.yaml.</p>
</div>
<div class="paragraph">
<p>Why do we recommend this approach? Let me give you four reasons.</p>
</div>
<div class="paragraph">
<p>First, it&#8217;s simpler and more explicit. Everything is in one place, so you see the complete picture.</p>
</div>
<div class="paragraph">
<p>Second, it&#8217;s easier to troubleshoot. When something goes wrong, you don&#8217;t have to trace through multiple files to understand the configuration.</p>
</div>
<div class="paragraph">
<p>Third, it&#8217;s the standard Helm pattern. This matches how most teams already work with Helm.</p>
</div>
<div class="paragraph">
<p>And fourth, it&#8217;s GitOps friendly. When you look at Git diffs, you can clearly see what changed for each environment.</p>
</div>
<div class="paragraph">
<p>Option two is to use values inline for overrides. You can combine a values file with inline overrides, but we don&#8217;t recommend this approach for several reasons.</p>
</div>
<div class="paragraph">
<p>First, it gets messy with complex configurations.</p>
</div>
<div class="paragraph">
<p>Second, you&#8217;ll run into YAML formatting issues with multiline strings.</p>
</div>
<div class="paragraph">
<p>Third, it&#8217;s harder to validate because you can&#8217;t test it with the helm template command.</p>
</div>
<div class="paragraph">
<p>And fourth, it&#8217;s less familiar to most engineers.</p>
</div>
<div class="paragraph">
<p>Our strong recommendation? Embrace some duplication. Keep complete values files per environment. It&#8217;s clearer and much easier to maintain in the long run.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-4-understanding-overlays">Section 4: Understanding Overlays</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now let&#8217;s talk about overlays and directory structure.</p>
</div>
<div class="paragraph">
<p>You might be wondering, why not put the Helm chart in a base directory that all environments share?</p>
</div>
<div class="paragraph">
<p>That&#8217;s a good question! For simple Helm charts like PostgreSQL that don&#8217;t have shared Kubernetes resources beyond secrets, we actually don&#8217;t need a base directory at all. Each environment can directly reference the Helm chart with its own values.</p>
</div>
<div class="paragraph">
<p>Our directory structure looks like this. We have an argocd folder that contains our Argo CD Application manifests. We have a base folder that&#8217;s actually empty for this use case. And then we have separate folders for dev, staging, and production environments.</p>
</div>
<div class="paragraph">
<p>Each environment folder contains three files. A kustomization.yaml file that tells Kustomize what to build, a values file specific to that environment, and a sealed secret file for encrypted credentials.</p>
</div>
<div class="paragraph">
<p>The key insight here is that the base directory is optional. Use it only when you have shared Kubernetes resources. For Helm charts where everything is environment-specific, you can skip it entirely.</p>
</div>
<div class="paragraph">
<p>This keeps things simple and easy to understand.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-5-installing-kustomize">Section 5: Installing Kustomize</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Alright, let&#8217;s get practical. First, you&#8217;ll need to install Kustomize on your local machine.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll need version 4.1.0 or later to use Helm chart inflation, which is the feature we&#8217;ll be using.</p>
</div>
<div class="paragraph">
<p>On your screen, you&#8217;ll see the installation commands. After installing, verify that it&#8217;s working by checking the version. You should see version 5.8.0 or later.</p>
</div>
<div class="paragraph">
<p>Once you have Kustomize installed, you&#8217;re ready to proceed with the setup.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-6-directory-structure-walkthrough">Section 6: Directory Structure Walkthrough</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Let&#8217;s take a closer look at how we organize our PostgreSQL deployment.</p>
</div>
<div class="paragraph">
<p>At the top level, we have the postgresql-gitops directory. Inside that, you&#8217;ll find four main folders.</p>
</div>
<div class="paragraph">
<p>The argocd folder contains our Argo CD configuration files. This includes an ApplicationSet for managing multiple environments, and individual Application files for dev, staging, and production if you want to manage them separately.</p>
</div>
<div class="paragraph">
<p>The base folder typically holds shared resources, but it&#8217;s empty in our case since we don&#8217;t have any shared Kubernetes resources.</p>
</div>
<div class="paragraph">
<p>Then we have three environment folders: dev, staging, and prod.</p>
</div>
<div class="paragraph">
<p>Each environment folder contains the same three types of files. A kustomization.yaml file that tells Kustomize what to include and how to build it, a values file with Helm values specific to that environment, and a sealed secret file containing encrypted credentials.</p>
</div>
<div class="paragraph">
<p>This structure gives you clear separation between environments while keeping everything in version control. When you want to change something in development, you know exactly which folder to look in. Same for staging and production.</p>
</div>
<div class="paragraph">
<p>It&#8217;s simple, organized, and scales well as your infrastructure grows.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-7-dev-environment-configuration">Section 7: Dev Environment Configuration</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now let&#8217;s examine the development environment configuration in detail.</p>
</div>
<div class="paragraph">
<p>The kustomization.yaml file is the heart of each environment. Let me walk you through what it does.</p>
</div>
<div class="paragraph">
<p>At the top, we specify that this is a Kustomization resource and set the namespace to dev. This means all resources will be deployed to the dev namespace.</p>
</div>
<div class="paragraph">
<p>In the resources section, we include our sealed secret for PostgreSQL credentials.</p>
</div>
<div class="paragraph">
<p>The most important part is the helmCharts section. This is where we tell Kustomize about the Helm chart we want to use.</p>
</div>
<div class="paragraph">
<p>We specify postgresql as the chart name, and provide the Bitnami Helm repository URL. We pin the version to 16.7.27 for reproducibility. This is important because it ensures everyone gets the same version of PostgreSQL.</p>
</div>
<div class="paragraph">
<p>We set the release name to postgresql and the namespace to dev. And finally, we point to our dev-specific values file, which is values-dev.yaml.</p>
</div>
<div class="paragraph">
<p>So what happens when you build this? Let me break it down.</p>
</div>
<div class="paragraph">
<p>First, Kustomize fetches the PostgreSQL Helm chart from the Bitnami repository.</p>
</div>
<div class="paragraph">
<p>Second, it renders the chart using the values from values-dev.yaml.</p>
</div>
<div class="paragraph">
<p>Third, it combines the rendered manifests with our sealed secret.</p>
</div>
<div class="paragraph">
<p>Fourth, it sets the namespace to dev for all resources.</p>
</div>
<div class="paragraph">
<p>And finally, it outputs complete, ready-to-deploy Kubernetes manifests.</p>
</div>
<div class="paragraph">
<p>All of this happens automatically when you run the kustomize build command.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-8-helm-values-explained">Section 8: Helm Values Explained</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now let&#8217;s look at the Helm values file for development.</p>
</div>
<div class="paragraph">
<p>This file customizes the PostgreSQL Helm chart specifically for the development environment.</p>
</div>
<div class="paragraph">
<p>At the top, we configure the container image. We&#8217;re using the Bitnami legacy PostgreSQL image, version 17.6.0.</p>
</div>
<div class="paragraph">
<p>Next, we configure authentication. We set the username to dev, which is environment-specific. We use postgres as the default database. And we reference an existing secret called postgresql-credentials for the password. This is the sealed secret we mentioned earlier.</p>
</div>
<div class="paragraph">
<p>Then we have the primary instance configuration. This includes several important settings.</p>
</div>
<div class="paragraph">
<p>First, the pg_hba configuration file. This controls client authentication. For development, we&#8217;re using trust-based authentication for local connections and connections from private IP ranges. This makes development easier, but you&#8217;d lock this down more in production.</p>
</div>
<div class="paragraph">
<p>Second, we have extended PostgreSQL configuration. We&#8217;re setting up logical replication with specific settings for write-ahead logging, replication slots, and maximum connections.</p>
</div>
<div class="paragraph">
<p>Third, we define resource limits. For development, we&#8217;re requesting 100 millicores of CPU and 512 megabytes of memory, with limits of 500 millicores and 1 gigabyte. These are smaller than what you&#8217;d use in production.</p>
</div>
<div class="paragraph">
<p>Finally, we have initialization scripts. When PostgreSQL starts for the first time, it will create two databases: service_foundry and keycloak. It will also grant privileges to the dev user on both databases.</p>
</div>
<div class="paragraph">
<p>When you compare this to production, your prod values file would have higher resource limits, stricter authentication rules, a production-specific username, and possibly different PostgreSQL settings based on your production requirements.</p>
</div>
<div class="paragraph">
<p>This is the power of having separate values files per environment. You can tune each environment independently.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-9-testing-locally">Section 9: Testing Locally</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Before we set up Argo CD, it&#8217;s a good idea to test that our Kustomize configuration actually works.</p>
</div>
<div class="paragraph">
<p>You can do this locally by navigating to your postgresql-gitops directory and running the kustomize build command with the enable-helm flag.</p>
</div>
<div class="paragraph">
<p>This will show you all the Kubernetes manifests that would be deployed, without actually deploying them. It&#8217;s a great way to verify everything looks correct.</p>
</div>
<div class="paragraph">
<p>If you want to actually deploy to your cluster, you can pipe the output to kubectl apply.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s talk about that enable-helm flag. Why is it required?</p>
</div>
<div class="paragraph">
<p>Kustomize doesn&#8217;t natively support Helm charts. When you include a helmCharts section in your kustomization.yaml file, you must use the enable-helm flag to tell Kustomize four things.</p>
</div>
<div class="paragraph">
<p>First, "Hey, I have Helm charts in here".</p>
</div>
<div class="paragraph">
<p>Second, "Please download these charts from the specified repository".</p>
</div>
<div class="paragraph">
<p>Third, "Render them using the values file I specified".</p>
</div>
<div class="paragraph">
<p>And fourth, "Include the rendered manifests in the final output".</p>
</div>
<div class="paragraph">
<p>Without this flag, Kustomize will simply ignore the helmCharts section, and your PostgreSQL won&#8217;t be deployed.</p>
</div>
<div class="paragraph">
<p>One important note: the enable-helm flag requires Kustomize version 4.1.0 or later. Make sure you have a recent version installed.</p>
</div>
<div class="paragraph">
<p>Soon, we&#8217;ll learn how to enable this flag in Argo CD as well.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-10-argo-cd-application">Section 10: Argo CD Application</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now let&#8217;s move to Argo CD. We&#8217;ll start by deploying just the development environment to keep things simple.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s understand what an Argo CD Application is.</p>
</div>
<div class="paragraph">
<p>An Application is a custom Kubernetes resource that tells Argo CD four key things.</p>
</div>
<div class="paragraph">
<p>First, where to find your manifests. This includes the Git repository URL and the path within that repository.</p>
</div>
<div class="paragraph">
<p>Second, what cluster and namespace to deploy to.</p>
</div>
<div class="paragraph">
<p>Third, how to sync. Should it happen automatically or manually?</p>
</div>
<div class="paragraph">
<p>And fourth, when to sync. Should it sync on Git changes, or only when you tell it to?</p>
</div>
<div class="paragraph">
<p>Think of it as a deployment configuration that Argo CD watches and keeps in sync with your desired state in Git.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at our Application manifest for the dev environment.</p>
</div>
<div class="paragraph">
<p>At the top, we give it a name: postgresql-dev. We create it in the argocd namespace, and we add a finalizer that ensures resources are cleaned up when the Application is deleted.</p>
</div>
<div class="paragraph">
<p>In the spec section, we define the source. This includes your Git repository URL, which you&#8217;ll need to update to point to your own repository. We set the target revision to main, which means we track the main branch. And we set the path to the dev directory in our repository.</p>
</div>
<div class="paragraph">
<p>Next, we define the destination. We specify the Kubernetes cluster to deploy to. The default value means the cluster where Argo CD is running. And we set the namespace to dev.</p>
</div>
<div class="paragraph">
<p>Finally, we configure the sync policy. We enable automated sync, which means Argo CD will automatically sync when it detects changes in Git.</p>
</div>
<div class="paragraph">
<p>We enable pruning, which removes resources that have been deleted from Git.</p>
</div>
<div class="paragraph">
<p>We enable self-heal, which reverts manual changes back to the Git state.</p>
</div>
<div class="paragraph">
<p>We tell it to create the namespace if it doesn&#8217;t exist.</p>
</div>
<div class="paragraph">
<p>And we configure retry logic for handling transient failures.</p>
</div>
<div class="paragraph">
<p>To deploy this Application, you simply apply the manifest with kubectl. Then you can check the status using kubectl or the Argo CD command-line interface.</p>
</div>
<div class="paragraph">
<p>If everything is configured correctly, you&#8217;ll see your application appear in the Argo CD web interface with a nice visual representation of all the deployed resources.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-11-benefits-recap">Section 11: Benefits Recap</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Let&#8217;s take a moment to recap the benefits of this approach.</p>
</div>
<div class="paragraph">
<p>First, we have clear separation. Development configuration lives in the dev directory, completely isolated from staging and production.</p>
</div>
<div class="paragraph">
<p>Second, we get easy code reviews. Git diffs show exactly what changed for each environment, making pull requests much easier to review.</p>
</div>
<div class="paragraph">
<p>Third, we have Helm compatibility. We&#8217;re leveraging the full Helm chart ecosystem while maintaining the structure of Kustomize.</p>
</div>
<div class="paragraph">
<p>And fourth, it&#8217;s scalable. Adding staging and production environments is straightforward. Just create new directories with their own values files.</p>
</div>
<div class="paragraph">
<p>This architecture gives you the best of both worlds: the flexibility of Helm charts and the organization of Kustomize.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-12-troubleshooting-the-enable-helm-error">Section 12: Troubleshooting the Enable-Helm Error</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now, you might encounter an error when Argo CD tries to sync your application. Don&#8217;t panic! This is completely expected and easy to fix.</p>
</div>
<div class="paragraph">
<p>The error message will say something like: "Failed to load target state, kustomize build failed, must specify enable-helm".</p>
</div>
<div class="paragraph">
<p>Let me explain why this happens.</p>
</div>
<div class="paragraph">
<p>Remember the enable-helm flag we used with the Kustomize command-line tool? Well, Argo CD uses Kustomize internally to build your manifests, but by default, it doesn&#8217;t enable Helm support.</p>
</div>
<div class="paragraph">
<p>We need to tell Argo CD: "Please use enable-helm when building Kustomize applications."</p>
</div>
<div class="paragraph">
<p>Unfortunately, Argo CD doesn&#8217;t provide a way to enable this flag per-application. You must configure it globally for all Kustomize applications by updating a ConfigMap called argocd-cm.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how to fix it.</p>
</div>
<div class="paragraph">
<p>First, you&#8217;ll patch the argocd-cm ConfigMap to add the enable-helm build option.</p>
</div>
<div class="paragraph">
<p>Second, you&#8217;ll restart the Argo CD repo server so it picks up the new configuration.</p>
</div>
<div class="paragraph">
<p>Third, you&#8217;ll wait for the repo server to be ready.</p>
</div>
<div class="paragraph">
<p>And finally, you&#8217;ll verify that the configuration was applied correctly.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll see the commands on screen. After running these, you need to refresh your application. You can do this by patching the Application with a hard refresh annotation, or you can delete and recreate the Application.</p>
</div>
<div class="paragraph">
<p>After these steps, your application should sync successfully!</p>
</div>
<div class="paragraph">
<p>If you&#8217;re installing Argo CD fresh, you can configure this from the start by creating a custom values file that includes the kustomize build options. This way, you won&#8217;t encounter the error at all.</p>
</div>
<div class="paragraph">
<p>For reference, all available Argo CD ConfigMap options are documented in the official Argo CD repository.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-13-scaling-to-multiple-environments">Section 13: Scaling to Multiple Environments</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>So far, we&#8217;ve deployed just the development environment. But what about staging and production?</p>
</div>
<div class="paragraph">
<p>You could create individual Application manifests for each environment. That would give you postgresql-dev-application.yaml, postgresql-staging-application.yaml, and postgresql-prod-application.yaml.</p>
</div>
<div class="paragraph">
<p>But this creates duplication and becomes tedious to manage. There&#8217;s a better way: ApplicationSet.</p>
</div>
<div class="paragraph">
<p>Let me explain what ApplicationSet is.</p>
</div>
<div class="paragraph">
<p>Argo CD&#8217;s ApplicationSet is like a template engine for Applications. It automatically creates multiple Application resources from a single, reusable template using generators.</p>
</div>
<div class="paragraph">
<p>Think of it this way: You have a generator that produces a list of environments, plus a template that defines how each Application should look. The result is multiple Applications, one for each environment.</p>
</div>
<div class="paragraph">
<p>In our case, the generator is a simple list of environments: dev, staging, and prod. The template is a reusable Application configuration. And the result is three Argo CD Applications, automatically created for us.</p>
</div>
<div class="paragraph">
<p>ApplicationSet uses generators to produce data, then applies that data to a template. There are several types of generators available.</p>
</div>
<div class="paragraph">
<p>The List generator uses a hardcoded list of values. This is what we&#8217;ll use.</p>
</div>
<div class="paragraph">
<p>The Git generator discovers directories or files in a repository automatically.</p>
</div>
<div class="paragraph">
<p>And the Cluster generator discovers registered Kubernetes clusters.</p>
</div>
<div class="paragraph">
<p>For each item produced by the generator, ApplicationSet creates an Application by filling in template variables.</p>
</div>
<div class="paragraph">
<p>Let me walk you through our ApplicationSet configuration.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-14-applicationset-configuration">Section 14: ApplicationSet Configuration</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Our ApplicationSet manifest starts with a name: postgresql-environments. This is created in the argocd namespace, just like individual Applications.</p>
</div>
<div class="paragraph">
<p>In the spec section, we define our generator. We&#8217;re using a list generator with three elements: dev, staging, and prod. Each element specifies both an environment name and a namespace.</p>
</div>
<div class="paragraph">
<p>Next, we define the template. This is where the magic happens.</p>
</div>
<div class="paragraph">
<p>The template metadata includes the application name, which uses a variable: postgresql-{site}. This means for dev, it becomes postgresql-dev. For staging, it becomes postgresql-staging. And for prod, it becomes postgresql-prod.</p>
</div>
<div class="paragraph">
<p>In the source section, we specify our Git repository and target revision. The path also uses a variable: demo-apps/postgresql-gitops/{site}. This points to the environment-specific directory.</p>
</div>
<div class="paragraph">
<p>The destination uses another variable for the namespace, so each environment deploys to its own namespace.</p>
</div>
<div class="paragraph">
<p>And finally, we configure the sync policy just like we did for the individual Application.</p>
</div>
<div class="paragraph">
<p>What gets created from this single ApplicationSet? Three complete Applications.</p>
</div>
<div class="paragraph">
<p>Application one: postgresql-dev deploys from the dev directory to the dev namespace.</p>
</div>
<div class="paragraph">
<p>Application two: postgresql-staging deploys from the staging directory to the staging namespace.</p>
</div>
<div class="paragraph">
<p>Application three: postgresql-prod deploys from the prod directory to the prod namespace.</p>
</div>
<div class="paragraph">
<p>To deploy the ApplicationSet, you simply apply the manifest with kubectl. Then you can check what Applications were created by listing all applications in the argocd namespace.</p>
</div>
<div class="paragraph">
<p>You should see all three: postgresql-dev, postgresql-staging, and postgresql-prod.</p>
</div>
<div class="paragraph">
<p>In the Argo CD web interface, you&#8217;ll see a beautiful visualization of all three environments, each with its own deployment status.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-15-why-use-applicationset">Section 15: Why Use ApplicationSet</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Let&#8217;s talk about why ApplicationSet is so powerful.</p>
</div>
<div class="paragraph">
<p>First, it follows the DRY principle: Don&#8217;t Repeat Yourself. You have one template instead of multiple duplicate manifests.</p>
</div>
<div class="paragraph">
<p>Second, it ensures consistency. All environments use the same configuration pattern, reducing the chance of configuration drift.</p>
</div>
<div class="paragraph">
<p>Third, it&#8217;s easy to scale. Want to add a new environment? Just add one line to the elements list in your generator.</p>
</div>
<div class="paragraph">
<p>Fourth, it&#8217;s GitOps-friendly. The environment list is tracked in Git, so all changes are version-controlled and reviewable.</p>
</div>
<div class="paragraph">
<p>And fifth, you have a cleaner repository. Fewer files to maintain means less clutter and easier navigation.</p>
</div>
<div class="paragraph">
<p>When should you use ApplicationSet versus individual Applications?</p>
</div>
<div class="paragraph">
<p>Use individual Applications when you only have one or two environments, when your environments differ significantly in structure, or when you&#8217;re just getting started and want to keep things simple.</p>
</div>
<div class="paragraph">
<p>Use ApplicationSet when you have three or more environments, when your environments follow the same pattern, or when you want to scale easily in the future.</p>
</div>
<div class="paragraph">
<p>For most production use cases, ApplicationSet is the way to go.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-16-securing-secrets">Section 16: Securing Secrets</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Now let&#8217;s talk about one of the most important topics in GitOps: secrets management.</p>
</div>
<div class="paragraph">
<p>So far, we&#8217;ve been referencing postgresql-credentials-secret files but haven&#8217;t explained what they are. Let&#8217;s fix that.</p>
</div>
<div class="paragraph">
<p>The problem is this: GitOps means everything in Git. But Kubernetes Secrets are only base64-encoded, not encrypted. Anyone with access to your repository can easily decode them.</p>
</div>
<div class="paragraph">
<p>This is a huge security risk. If you commit a regular Kubernetes Secret to your Git repository, it&#8217;s not really secret at all.</p>
</div>
<div class="paragraph">
<p>The solution is called SealedSecrets, developed by Bitnami.</p>
</div>
<div class="paragraph">
<p>SealedSecrets solves this problem using public-key cryptography. Here&#8217;s how it works.</p>
</div>
<div class="paragraph">
<p>Step one: You encrypt your secret using a public key. This encrypted secret is safe to commit to Git.</p>
</div>
<div class="paragraph">
<p>Step two: Only the SealedSecrets controller running inside your Kubernetes cluster has the private key needed to decrypt it.</p>
</div>
<div class="paragraph">
<p>Step three: You commit the encrypted SealedSecret to your Git repository. It&#8217;s completely safe.</p>
</div>
<div class="paragraph">
<p>Step four: Argo CD deploys the SealedSecret to your cluster, just like any other resource.</p>
</div>
<div class="paragraph">
<p>Step five: The SealedSecrets controller detects the new SealedSecret, decrypts it using its private key, and creates the actual Secret in your cluster.</p>
</div>
<div class="paragraph">
<p>The benefits are clear.</p>
</div>
<div class="paragraph">
<p>First, it&#8217;s secure. Secrets are properly encrypted, not just encoded.</p>
</div>
<div class="paragraph">
<p>Second, it&#8217;s GitOps-compatible. You can safely commit encrypted secrets to Git.</p>
</div>
<div class="paragraph">
<p>Third, it supports per-environment secrets. You can have different secrets for dev, staging, and production.</p>
</div>
<div class="paragraph">
<p>And fourth, it&#8217;s declarative. Secrets are managed as code through your CI/CD pipelines.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-17-creating-sealed-secrets">Section 17: Creating Sealed Secrets</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>To make creating sealed secrets easy, I&#8217;ve created a helper script.</p>
</div>
<div class="paragraph">
<p>You run the script with environment variables for your passwords and the target namespace. The script outputs an encrypted secret file that you can safely commit to Git.</p>
</div>
<div class="paragraph">
<p>Let me explain what the script does step by step.</p>
</div>
<div class="paragraph">
<p>First, it creates a regular Kubernetes Secret manifest, but with the dry-run flag. This means it doesn&#8217;t actually create the secret in your cluster, it just generates the YAML file.</p>
</div>
<div class="paragraph">
<p>Second, it fetches the public encryption key from your SealedSecrets controller running in the cluster.</p>
</div>
<div class="paragraph">
<p>Third, it encrypts the secret using that public key. This is the critical step.</p>
</div>
<div class="paragraph">
<p>Fourth, it outputs a SealedSecret YAML file that&#8217;s safe to commit to Git.</p>
</div>
<div class="paragraph">
<p>And finally, it cleans up the temporary files.</p>
</div>
<div class="paragraph">
<p>The resulting SealedSecret can only be decrypted by the controller in your cluster. Even if someone gets access to your Git repository, they cannot decrypt your secrets.</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve created your sealed secret, you commit it to Git and push it. Argo CD will deploy it automatically.</p>
</div>
<div class="paragraph">
<p>Then, the SealedSecrets controller in your cluster detects the new SealedSecret, decrypts it using its private key, and creates the actual Secret. PostgreSQL can then use this secret for authentication.</p>
</div>
<div class="paragraph">
<p>Perfect! You now have secure secrets in a GitOps workflow.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-18-putting-it-all-together">Section 18: Putting It All Together</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Let&#8217;s review what we&#8217;ve built and how all the pieces fit together.</p>
</div>
<div class="paragraph">
<p>We have a clear directory structure with an argocd folder for configurations, and separate folders for dev, staging, and prod environments.</p>
</div>
<div class="paragraph">
<p>Each environment has three key files: a kustomization file that tells Kustomize what to build, environment-specific Helm values, and encrypted secrets.</p>
</div>
<div class="paragraph">
<p>For Argo CD configuration, we have two approaches available. We can use individual Applications, one per environment. Or we can use a single ApplicationSet for all environments, which is the recommended approach.</p>
</div>
<div class="paragraph">
<p>Now let me walk you through the complete workflow.</p>
</div>
<div class="paragraph">
<p>It starts when you push a change to Git.</p>
</div>
<div class="paragraph">
<p>Argo CD detects the change within seconds.</p>
</div>
<div class="paragraph">
<p>It runs Kustomize build with the enable-helm flag.</p>
</div>
<div class="paragraph">
<p>Kustomize downloads the specified Helm chart from the repository.</p>
</div>
<div class="paragraph">
<p>It renders the chart using the environment-specific values.</p>
</div>
<div class="paragraph">
<p>The rendered manifests are deployed to your cluster.</p>
</div>
<div class="paragraph">
<p>The SealedSecrets controller automatically decrypts any sealed secrets.</p>
</div>
<div class="paragraph">
<p>And finally, PostgreSQL starts using the decrypted credentials.</p>
</div>
<div class="paragraph">
<p>This entire process is automated, auditable, and secure. Every change is tracked in Git. Every deployment is reproducible. And every secret is encrypted.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion-script">Conclusion Script</h2>
<div class="sectionbody">
<div class="sidebarblock script">
<div class="content">
<div class="paragraph">
<p>Congratulations! You&#8217;ve learned how to combine Kustomize and Helm to manage multi-environment deployments with Argo CD.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s recap the key takeaways from this video.</p>
</div>
<div class="paragraph">
<p>First, combining Kustomize and Helm gives you the best of both worlds: the structure and organization of Kustomize with the flexibility and power of Helm charts.</p>
</div>
<div class="paragraph">
<p>Second, using one complete values file per environment may involve some duplication, but it&#8217;s much clearer and easier to maintain than trying to merge multiple files.</p>
</div>
<div class="paragraph">
<p>Third, you must enable the enable-helm flag in Argo CD&#8217;s ConfigMap for Helm chart inflation to work.</p>
</div>
<div class="paragraph">
<p>Fourth, ApplicationSet makes managing multiple environments incredibly easy. One template, multiple environments.</p>
</div>
<div class="paragraph">
<p>And fifth, SealedSecrets lets you safely store encrypted secrets in Git, solving one of the biggest challenges in GitOps.</p>
</div>
<div class="paragraph">
<p>What should you do next?</p>
</div>
<div class="paragraph">
<p>Try this pattern with your own Helm charts. Start with something simple, like nginx or postgresql.</p>
</div>
<div class="paragraph">
<p>Explore Argo CD&#8217;s other ApplicationSet generators, like the Git generator and Cluster generator.</p>
</div>
<div class="paragraph">
<p>Set up promotion workflows to move changes from dev to staging to production in a controlled way.</p>
</div>
<div class="paragraph">
<p>And consider adding automated tests that run before deployment to catch issues early.</p>
</div>
<div class="paragraph">
<p>I hope this video has been helpful! If you found it useful, please give it a thumbs up and subscribe for more Kubernetes and DevOps content.</p>
</div>
<div class="paragraph">
<p>If you have questions or want to share your own experiences with Kustomize and Helm, please leave a comment below. I&#8217;d love to hear from you.</p>
</div>
<div class="paragraph">
<p>Thanks for watching, and happy deploying!</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="video-production-notes">Video Production Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="suggested-video-structure">Suggested Video Structure</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Total estimated runtime: 35-45 minutes</strong></p>
</div>
<div class="paragraph">
<p><strong>Part 1: Introduction and Problem (5-7 minutes)</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Introduction script</p>
</li>
<li>
<p>The Challenge script</p>
</li>
<li>
<p>The Better Way script</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Part 2: Core Concepts (8-10 minutes)</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Understanding Values Files script</p>
</li>
<li>
<p>Understanding Overlays script</p>
</li>
<li>
<p>Installing Kustomize script</p>
</li>
<li>
<p>Directory Structure Walkthrough script</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Part 3: Implementation (12-15 minutes)</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dev Environment Configuration script</p>
</li>
<li>
<p>Helm Values Explained script</p>
</li>
<li>
<p>Testing Locally script</p>
</li>
<li>
<p>Argo CD Application script</p>
</li>
<li>
<p>Benefits Recap script</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Part 4: Advanced Topics (8-10 minutes)</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Troubleshooting the Enable-Helm Error script</p>
</li>
<li>
<p>Scaling to Multiple Environments script</p>
</li>
<li>
<p>ApplicationSet Configuration script</p>
</li>
<li>
<p>Why Use ApplicationSet script</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Part 5: Security and Conclusion (7-8 minutes)</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Securing Secrets script</p>
</li>
<li>
<p>Creating Sealed Secrets script</p>
</li>
<li>
<p>Putting It All Together script</p>
</li>
<li>
<p>Conclusion script</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="screen-recording-suggestions">Screen Recording Suggestions</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>For each section, consider showing:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Introduction</strong>: Show the final demo of all three environments running</p>
</li>
<li>
<p><strong>Problem/Solution</strong>: Show side-by-side comparison of old vs new approach</p>
</li>
<li>
<p><strong>Directory Structure</strong>: Show file explorer or terminal tree view</p>
</li>
<li>
<p><strong>Configuration files</strong>: Show the actual YAML files with syntax highlighting</p>
</li>
<li>
<p><strong>Kustomize build</strong>: Show terminal output of kustomize build command</p>
</li>
<li>
<p><strong>Argo CD</strong>: Show the Argo CD web UI with applications syncing</p>
</li>
<li>
<p><strong>Troubleshooting</strong>: Show the actual error in Argo CD UI</p>
</li>
<li>
<p><strong>ApplicationSet</strong>: Show all three applications being created automatically</p>
</li>
<li>
<p><strong>Sealed Secrets</strong>: Show the script running and the encrypted output</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Timing suggestions:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pause for 2-3 seconds after introducing a new concept</p>
</li>
<li>
<p>Slow down when explaining complex topics like SealedSecrets</p>
</li>
<li>
<p>Speed up slightly during review/recap sections</p>
</li>
<li>
<p>Add music during transitions between major sections</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="voiceover-tips">Voiceover Tips</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>For best results with text-to-speech:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use short, declarative sentences</p>
</li>
<li>
<p>Add pauses with punctuation (commas, periods)</p>
</li>
<li>
<p>Emphasize key terms by putting them in their own sentence</p>
</li>
<li>
<p>Repeat important concepts in different words</p>
</li>
<li>
<p>Use transitions like "Now", "Next", "First", "Finally"</p>
</li>
<li>
<p>End sections with summaries</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Recommended TTS settings:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Speed: 0.9x (slightly slower than normal)</p>
</li>
<li>
<p>Pause at periods: 0.5 seconds</p>
</li>
<li>
<p>Pause at commas: 0.3 seconds</p>
</li>
<li>
<p>Pitch: Neutral to slightly warm</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="youtube-publishing-content">YouTube Publishing Content</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="video-title">Video Title</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Kustomize + Helm + Argo CD: The Complete Guide to Multi-Environment GitOps Deployments</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Alternative titles:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>How to Manage Multiple Environments with Kustomize, Helm, and Argo CD</em></p>
</li>
<li>
<p><em>GitOps Made Easy: Kustomize with Helm Charts in Argo CD (Complete Tutorial)</em></p>
</li>
<li>
<p><em>Deploy to Dev, Staging &amp; Prod Automatically with Kustomize and Argo CD</em></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="video-description">Video Description</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Learn how to combine Kustomize and Helm to manage Kubernetes applications across multiple environments (dev, staging, production) using GitOps with Argo CD.

In this comprehensive tutorial, I'll show you how to solve the common problem of managing different configurations for multiple environments while keeping everything version-controlled in Git.

 What You'll Learn:
 Why combining Kustomize and Helm makes sense
 How to structure your Git repository for multi-environment deployments
 Setting up Kustomize with Helm chart inflation
 Deploying single environments with Argo CD Applications
 Scaling to multiple environments with ApplicationSet
 Securing secrets with SealedSecrets
 Troubleshooting common issues

 Chapters:
00:00 Introduction
05:00 The Challenge with Multi-Environment Deployments
07:30 Why Kustomize + Helm?
12:00 Understanding Values Files (Can't Merge!)
17:00 Directory Structure Best Practices
22:00 Development Environment Configuration
27:00 Testing Locally with Kustomize
30:00 Deploying with Argo CD
35:00 Troubleshooting: The --enable-helm Error
40:00 ApplicationSet for Multiple Environments
48:00 Securing Secrets with SealedSecrets
55:00 Complete Workflow Overview
58:00 Conclusion &amp; Next Steps

 Example Repository:
https://github.com/nsalexamy/service-foundry-argocd

 Blog Article:
[Link to your blog post]

 Tools Used:
 Kustomize v5.8.0+
 Helm Charts (Bitnami PostgreSQL)
 Argo CD
 SealedSecrets
 Kubernetes

 Important Notes:
 You MUST use --enable-helm with Kustomize for Helm charts
 Configure kustomize.buildOptions in argocd-cm ConfigMap
 Values files cannot be merged (one complete file per environment)

 Prerequisites:
 Basic Kubernetes knowledge
 Understanding of Helm charts
 Familiarity with GitOps concepts
 kubectl and kustomize installed

 Key Takeaways:
 One complete values file per environment (embrace duplication!)
 Use ApplicationSet for 3+ environments
 SealedSecrets for secure GitOps
 Enable Helm globally in Argo CD ConfigMap

 Connect with me:
 LinkedIn: [Your LinkedIn]
 GitHub: [Your GitHub]
 Blog: [Your Blog]

#Kubernetes #ArgoCD #Kustomize #Helm #GitOps #DevOps #CloudNative #CNCF

 If this video helped you, please like and subscribe for more Kubernetes and DevOps content!
 Have questions? Drop them in the comments below!

---
Music: [If applicable]
Video Editing: [If applicable]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="youtube-tags">YouTube Tags</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">kubernetes
argocd
kustomize
helm
gitops
devops
cloud native
kubernetes tutorial
argocd tutorial
kustomize tutorial
helm charts
multi environment deployment
kubernetes deployment
continuous deployment
infrastructure as code
kubernetes gitops
applicationset
sealed secrets
kubernetes secrets
helm values
kustomize overlay
kubernetes environments
dev staging production
kubernetes best practices
cloud native applications
CNCF
postgresql kubernetes
bitnami helm charts
kubernetes automation
declarative kubernetes
kubernetes configuration management
helm chart customization
kustomize helm integration</code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="linkedin-publishing-content">LinkedIn Publishing Content</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="article-title">Article Title</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">The Complete Guide to Multi-Environment Kubernetes Deployments with Kustomize, Helm, and Argo CD</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linkedin-summary">LinkedIn Summary</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Managing Kubernetes applications across dev, staging, and production environments shouldn't feel like herding cats. Yet many teams struggle with configuration management, ending up with duplicated Application manifests, scattered values files, and no clear promotion path.

I've written a comprehensive guide that shows you how to solve this problem by combining three powerful tools: Kustomize, Helm, and Argo CD.

 The Problem:
When deploying Helm charts with Argo CD, the typical approach of embedding values in Application manifests quickly becomes unmanageable as you scale. You face:
 Tight coupling between configuration and deployment definitions
 Poor reusability across environments
 Difficult code reviews
 No clear promotion strategy

 The Solution:
By introducing Kustomize as a layer between Argo CD and Helm, you gain:
 Clean separation: Each environment gets its own directory
 GitOps-friendly: Everything version-controlled with clear structure
 Easy promotion: Standard Git workflows for moving changes
 Better reviews: Clear diffs showing environment-specific changes

 What's Covered:

**Core Concepts:**
 Why Kustomize values files can't be merged (and what to do about it)
 Directory structure best practices
 When to use base overlays vs. per-environment configs

**Implementation:**
 Setting up Kustomize with Helm chart inflation
 Configuring Argo CD Applications
 Using ApplicationSet for multiple environments
 The critical --enable-helm flag (and how to fix errors)

**Security:**
 Managing secrets with SealedSecrets
 Encrypting credentials for GitOps workflows

**Real Example:**
I use PostgreSQL deployment across three environments (dev, staging, prod) to demonstrate every concept with working code.

 Key Insight:
One of the most important lessons? Don't fight Kustomize's design. Each environment should have a complete values file. Yes, there's duplication. But the clarity and maintainability you gain far outweigh the DRY principle here.

 I've also created a companion YouTube video (35-45 minutes) with voiceover narration walking through every step. Perfect for visual learners or those who want to follow along.

Whether you're managing 3 environments or 30, this pattern scales beautifully. It's how we manage production Kubernetes workloads across multiple teams.

Have you tried combining Kustomize and Helm? What challenges have you faced? Let's discuss in the comments!

#Kubernetes #ArgoCD #Kustomize #Helm #GitOps #DevOps #CloudNative #CNCF #PlatformEngineering #InfrastructureAsCode #SRE #KubernetesBestPractices

 Read the full article: [Link]
 Watch the video tutorial: [Link]
 Example code: [Link]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linkedin-article-opening-hook">LinkedIn Article Opening Hook</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">You've got three environments. Three sets of Kubernetes resources. Three different configurations. And somehow, you're managing them with copy-paste and prayer.

There's a better way.

In this guide, I'll show you exactly how to manage multi-environment Kubernetes deployments using Kustomize, Helm, and Argo CDthe GitOps way.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linkedin-hashtags-optimized-set">LinkedIn Hashtags (Optimized Set)</h3>
<div class="paragraph">
<p><strong>Primary hashtags (High engagement):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">#Kubernetes
#DevOps
#CloudNative
#GitOps
#ArgoCD</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Secondary hashtags (Targeted):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">#Kustomize
#Helm
#CNCF
#PlatformEngineering
#SRE
#InfrastructureAsCode
#ContainerOrchestration
#CloudComputing
#DevSecOps
#KubernetesBestPractices</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Long-tail hashtags (Specific):</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">#KubernetesTutorial
#ArgoCDTutorial
#HelmCharts
#MultiEnvironmentDeployment
#KubernetesDeployment
#ContinuousDeployment
#DeclarativeKubernetes
#KubernetesAutomation</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linkedin-posting-strategy">LinkedIn Posting Strategy</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Best times to post on LinkedIn:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tuesday to Thursday: 8-10 AM, 12-1 PM (your timezone)</p>
</li>
<li>
<p>Avoid Mondays (people catching up) and Fridays (winding down)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Engagement tactics:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Ask a question</strong> in the first comment to start discussion</p>
</li>
<li>
<p><strong>Tag relevant people</strong> or companies (Argo CD project, CNCF, etc.)</p>
</li>
<li>
<p><strong>Respond quickly</strong> to early comments (first 2 hours are critical)</p>
</li>
<li>
<p><strong>Share in relevant groups</strong> (Kubernetes, DevOps, Cloud Native)</p>
</li>
<li>
<p><strong>Pin a top comment</strong> with links to resources</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Sample first comment to pin:</strong></p>
</div>
<div class="paragraph">
<p>" Hey everyone! I spent the last month refining this approach in production. Here are the key resources:</p>
</div>
<div class="paragraph">
<p> Full article with code examples: [link]
 Video walkthrough (35 min): [link]
 GitHub repo with working examples: [link]
 SealedSecrets setup guide: [link]</p>
</div>
<div class="paragraph">
<p>What&#8217;s your biggest challenge with multi-environment Kubernetes deployments? I&#8217;ll try to answer questions in the comments!"</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="linkedin-article-tags-backend">LinkedIn Article Tags (Backend)</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When publishing on LinkedIn as an article, use these tags in the LinkedIn article editor:</p>
</div>
<div class="paragraph">
<p><strong>Skills to tag:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>DevOps</p>
</li>
<li>
<p>Helm (Package Manager)</p>
</li>
<li>
<p>GitOps</p>
</li>
<li>
<p>Argo CD</p>
</li>
<li>
<p>Cloud Computing</p>
</li>
<li>
<p>Container Orchestration</p>
</li>
<li>
<p>Infrastructure as Code</p>
</li>
<li>
<p>Site Reliability Engineering</p>
</li>
<li>
<p>Platform Engineering</p>
</li>
<li>
<p>Continuous Integration and Continuous Delivery (CI/CD)</p>
</li>
<li>
<p>Configuration Management</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="social-media-promotion-plan">Social Media Promotion Plan</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="twitterx-thread-7-tweets">Twitter/X Thread (7 tweets)</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Tweet 1/7 
Managing Kubernetes apps across dev, staging &amp; prod shouldn't be this hard.

I just published a complete guide on combining Kustomize + Helm + Argo CD for GitOps multi-environment deployments.

Here's what you need to know 

#Kubernetes #DevOps #GitOps

---

Tweet 2/7
The Problem: Most teams embed Helm values in Argo CD manifests.

This creates:
 Tight coupling
 Poor reusability
 Messy Git diffs
 No clear promotion path

There's a better way...

---

Tweet 3/7
The Solution: Use Kustomize as an organizer for your Helm charts.

 Each environment = its own directory
 Clear Git structure
 Easy promotion (just merge PRs!)
 Better code reviews

---

Tweet 4/7
Key Insight #1:

Kustomize CANNOT merge Helm values files.

Unlike helm install --values base.yaml --values dev.yaml, you can only use ONE values file per environment.

The fix? Embrace duplication. One complete values file per env.

---

Tweet 5/7
Key Insight #2:

You MUST enable --enable-helm in Argo CD.

Add this to argocd-cm ConfigMap:
kustomize.buildOptions: "--enable-helm"

Then restart the repo-server.

This trips up everyone the first time!

---

Tweet 6/7
Pro tip: Use ApplicationSet for 3+ environments.

One template = Multiple apps automatically created.

Way better than copy-pasting Application manifests for each environment.

---

Tweet 7/7
I covered everything:
 Directory structure
 Values file patterns
 ApplicationSet
 SealedSecrets
 Real PostgreSQL example

 Full guide: [link]
 Video tutorial: [link]
 Code: [link]

Questions? Drop them below! </code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reddit-posts">Reddit Posts</h3>
<div class="paragraph">
<p><strong>For r/kubernetes:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Title: [Tutorial] Complete Guide to Multi-Environment Deployments with Kustomize, Helm, and Argo CD

Body:
I've written a comprehensive guide on managing Kubernetes applications across multiple environments using Kustomize with Helm charts in Argo CD.

This was born from production pain points managing 10+ environments across multiple teams. The common approach of embedding Helm values in Argo CD Application manifests doesn't scale.

**What's covered:**
- Why combine Kustomize and Helm (and when not to)
- Directory structure patterns
- Configuration file examples
- ApplicationSet for automation
- SealedSecrets for GitOps-safe secrets
- Common gotchas and how to fix them

**Key takeaway:**
Kustomize can't merge Helm values files. You need one complete values file per environment. Fighting this design decision will only bring pain.

 Article: [link]
 Video walkthrough: [link]
 Example repo: [link]

Happy to answer questions!</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>For r/devops:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">Title: How I Solved Multi-Environment Config Management with GitOps (Kustomize + Helm + Argo CD)

Body:
After months of wrestling with configuration management across dev, staging, and prod environments, I finally landed on a pattern that works beautifully.

The stack: Kustomize + Helm + Argo CD

The insight: Stop trying to merge values files. Embrace duplication.

I documented the entire approach with a real PostgreSQL deployment example.

**Covers:**
- GitOps directory structure
- Helm values organization
- Argo CD ApplicationSet patterns
- Secret management with SealedSecrets
- The critical --enable-helm flag everyone forgets

Full write-up: [link]
Video tutorial: [link]

What's your approach to multi-env config management?</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dev-to-post-excerpt">Dev.to Post Excerpt</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="markdown"><span class="nn">---</span>
<span class="na">title</span><span class="pi">:</span> <span class="s">The Complete Guide to Multi-Environment Kubernetes Deployments with Kustomize, Helm, and Argo CD</span>
<span class="na">published</span><span class="pi">:</span> <span class="kc">true</span>
<span class="na">description</span><span class="pi">:</span> <span class="s">Learn how to manage dev, staging, and production Kubernetes deployments using GitOps with Kustomize, Helm charts, and Argo CD ApplicationSets.</span>
<span class="na">tags</span><span class="pi">:</span> <span class="s">kubernetes, devops, gitops, argocd</span>
<span class="na">cover_image</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">your-cover-image-url</span><span class="pi">]</span>
<span class="na">canonical_url</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">your-blog-url</span><span class="pi">]</span>
<span class="nn">---</span>

Managing Kubernetes applications across multiple environments shouldn't feel like juggling chainsaws. Yet here we are, copy-pasting Application manifests, scattering values files, and hoping nothing breaks in production.

In this guide, I'll show you how to solve this problem by combining three powerful tools: Kustomize, Helm, and Argo CD.

[Read more...]</code></pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>