<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Using Longhorn - Snapshots, S3 Backups, and Restore Operations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        body {
            font-family: sans-serif;
            background-color: #f8fafc;
            color: #1f2937;
            margin: 0;
            padding: 0;
        }
    </style>
    
</head>
<body>
<div id="toc" class="toc">
<div id="toctitle">On this page</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#longhorn-snapshot-and-backup">Longhorn Snapshot and Backup</a>
<ul class="sectlevel2">
<li><a href="#what-longhorn-ha-actually-protects-you-from">What Longhorn HA Actually Protects You From</a></li>
<li><a href="#what-ha-does-not-protect-you-from-critical">What HA Does Not Protect You From (Critical)</a></li>
<li><a href="#where-snapshots-fit-local-fast-operational">Where Snapshots Fit (Local, Fast, Operational)</a></li>
<li><a href="#where-backups-fit-off-cluster-long-term-dr">Where Backups Fit (Off-Cluster, Long-Term, DR)</a></li>
<li><a href="#how-ha-snapshots-and-backups-complement-each-other">How HA, Snapshots, and Backups Complement Each Other</a></li>
<li><a href="#concrete-examples">Concrete Examples</a></li>
<li><a href="#why-ha-only-is-dangerous">Why "HA Only" Is Dangerous</a></li>
<li><a href="#practical-recommendations">Practical Recommendations</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
<li><a href="#step-1-create-an-aws-s3-bucket">Step 1: Create an AWS S3 Bucket</a></li>
<li><a href="#step-2-create-an-aws-iam-user-and-policy">Step 2: Create an AWS IAM User and Policy</a>
<ul class="sectlevel2">
<li><a href="#2-1-create-an-iam-policy">2.1 Create an IAM Policy</a></li>
<li><a href="#2-2-create-an-iam-user">2.2 Create an IAM User</a></li>
<li><a href="#2-3-create-access-keys">2.3 Create Access Keys</a></li>
</ul>
</li>
<li><a href="#step-3-create-a-kubernetes-secret">Step 3: Create a Kubernetes Secret</a>
<ul class="sectlevel2">
<li><a href="#method-1-create-secret-using-kubectl">Method 1: Create Secret Using kubectl</a></li>
<li><a href="#method-2-create-secret-using-yaml-recommended-for-gitops">Method 2: Create Secret Using YAML (Recommended for GitOps)</a></li>
</ul>
</li>
<li><a href="#step-4-configure-longhorn-backup-target">Step 4: Configure Longhorn Backup Target</a></li>
<li><a href="#step-5-verify-configuration">Step 5: Verify Configuration</a></li>
<li><a href="#troubleshooting">Troubleshooting</a>
<ul class="sectlevel2">
<li><a href="#error-access-denied-or-aws-error-access-denied">Error: "Access Denied" or "AWS Error: Access Denied"</a></li>
<li><a href="#error-unable-to-list-s3-bucket-or-invalid-endpoint">Error: "Unable to List S3 Bucket" or "Invalid Endpoint"</a></li>
<li><a href="#error-backup-target-not-ready-or-secret-not-found">Error: "Backup Target Not Ready" or "Secret Not Found"</a></li>
<li><a href="#additional-troubleshooting-commands">Additional Troubleshooting Commands</a></li>
</ul>
</li>
<li><a href="#how-to-create-a-backup">How to Create a Backup</a>
<ul class="sectlevel2">
<li><a href="#manual-backup-creation">Manual Backup Creation</a></li>
<li><a href="#automated-backup-recurring-job">Automated Backup (Recurring Job)</a></li>
</ul>
</li>
<li><a href="#making-changes-after-backup-example-postgresql-table-creation">Making Changes After Backup (Example: PostgreSQL Table Creation)</a></li>
<li><a href="#restore-from-snapshot">Restore from Snapshot</a>
<ul class="sectlevel2">
<li><a href="#method-1-revert-to-snapshot-in-place-restore">Method 1: Revert to Snapshot (In-Place Restore)</a></li>
<li><a href="#method-2-create-volume-from-snapshot-clone-and-test">Method 2: Create Volume from Snapshot (Clone and Test)</a></li>
<li><a href="#snapshot-vs-backup-when-to-use-each">Snapshot vs Backup: When to Use Each</a></li>
<li><a href="#best-practices">Best Practices</a></li>
</ul>
</li>
<li><a href="#restoring-from-backup">Restoring from Backup</a>
<ul class="sectlevel2">
<li><a href="#basic-backup-restore-workflow">Basic Backup Restore Workflow</a></li>
<li><a href="#restoring-postgresql-with-argocd-management">Restoring PostgreSQL with ArgoCD Management</a></li>
</ul>
</li>
<li><a href="#deleting-snapshots-and-backups">Deleting Snapshots and Backups</a>
<ul class="sectlevel2">
<li><a href="#deleting-snapshots">Deleting Snapshots</a></li>
<li><a href="#deleting-backups">Deleting Backups</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="imageblock img-wide">
<div class="content">
<img src="images/longhorn-snapshots-and-backups.png" alt="longhorn snapshots and backups">
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Longhorn is a distributed block storage system for Kubernetes that provides high availability and disaster recovery for persistent volumes. This guide explains how to configure AWS S3 as a backup target for Longhorn volumes, implement backup and restore procedures, and understand the distinctions between HA, snapshots, and backups.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites">Prerequisites</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Longhorn Installed</strong>: Kubernetes cluster with Longhorn v1.11.0 or later.</p>
</li>
<li>
<p><strong>AWS Account</strong>: Access to create S3 buckets and IAM resources.</p>
</li>
<li>
<p><strong>AWS CLI</strong> (Optional): Useful for verifying bucket creation and permissions.</p>
</li>
<li>
<p><strong>kubectl</strong>: Configured with access to create secrets in the <code>longhorn-system</code> namespace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="longhorn-snapshot-and-backup">Longhorn Snapshot and Backup</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>"If Longhorn already keeps my volumes HA across 3 nodes / AZs, why do I need snapshots and backups at all?"</em></p>
</div>
<div class="paragraph">
<p><strong>The key is this:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HA protects you from infrastructure failure.</strong></p>
</li>
<li>
<p><strong>Snapshots and backups protect you from everything else.</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>They solve different classes of problems.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="what-longhorn-ha-actually-protects-you-from">What Longhorn HA Actually Protects You From</h3>
<div class="paragraph">
<p>Longhorn&#8217;s High Availability ensures your data remains available despite <strong>infrastructure-level failures</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Node failures</strong>: If a Kubernetes node crashes, dies, or becomes unreachable.</p>
</li>
<li>
<p><strong>Disk failures</strong>: When a physical disk fails on a node.</p>
</li>
<li>
<p><strong>Availability Zone outages</strong>: If an entire AZ goes down (when replicas are spread across AZs).</p>
</li>
<li>
<p><strong>Pod evictions</strong>: Normal cluster operations like node draining or autoscaling.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>How it works</strong>: Longhorn creates multiple replicas (typically 3) of your volume data, each stored on a different node. If one replica becomes unavailable, the volume continues operating seamlessly using healthy replicas.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="what-ha-does-not-protect-you-from-critical">What HA Does Not Protect You From (Critical)</h3>
<div class="paragraph">
<p>HA replication propagates <strong>all changes</strong> to all replicas—including destructive ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Accidental deletion</strong>: Delete a file or database record? <strong>All replicas reflect the deletion immediately.</strong></p>
</li>
<li>
<p><strong>Data corruption</strong>: Application bug corrupts data? <strong>All replicas get the corrupted data.</strong></p>
</li>
<li>
<p><strong>Ransomware/malware</strong>: Malicious encryption or data modification? <strong>Replicated to all copies.</strong></p>
</li>
<li>
<p><strong>Bad migrations</strong>: Database schema migration fails halfway? <strong>HA can&#8217;t roll it back.</strong></p>
</li>
<li>
<p><strong>Human error</strong>: Wrong <code>kubectl delete</code>, misconfigured app, accidental overwrite? <strong>Replicated everywhere.</strong></p>
</li>
<li>
<p><strong>Cluster-wide disasters</strong>: Control plane failure, cluster misconfiguration, namespace deletion.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Critical insight</strong>: HA keeps your data available <em>as-is</em>. It doesn&#8217;t protect you from <em>what</em> the data becomes.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="where-snapshots-fit-local-fast-operational">Where Snapshots Fit (Local, Fast, Operational)</h3>
<div class="paragraph">
<p>Longhorn snapshots are <strong>point-in-time copies stored locally within the cluster</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Use cases</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pre-upgrade safety</strong>: Take a snapshot before upgrading an application or database schema.</p>
</li>
<li>
<p><strong>Fast rollback</strong>: Restore to a known-good state in seconds/minutes.</p>
</li>
<li>
<p><strong>Operational testing</strong>: Clone volumes for testing without affecting production.</p>
</li>
<li>
<p><strong>Hourly/daily operational checkpoints</strong>: Frequent snapshots with short retention.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Characteristics</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Fast</strong>: Snapshot creation and restoration happen in seconds.</p>
</li>
<li>
<p><strong>Local</strong>: Stored within the Longhorn cluster (same infrastructure).</p>
</li>
<li>
<p><strong>Space-efficient</strong>: Use delta/incremental storage.</p>
</li>
<li>
<p><strong>Limited lifespan</strong>: Typically kept for hours to days.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Limitation</strong>: Snapshots are stored <em>in the same cluster</em>. If the cluster is lost or the Longhorn system itself is compromised, snapshots are lost too.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="where-backups-fit-off-cluster-long-term-dr">Where Backups Fit (Off-Cluster, Long-Term, DR)</h3>
<div class="paragraph">
<p>Longhorn backups are <strong>snapshots uploaded to external storage</strong> (S3, NFS, etc.).</p>
</div>
<div class="paragraph">
<p><strong>Use cases</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Disaster recovery (DR)</strong>: Recover from complete cluster failure.</p>
</li>
<li>
<p><strong>Cross-cluster migration</strong>: Restore volumes in a different cluster.</p>
</li>
<li>
<p><strong>Compliance and retention</strong>: Long-term data retention policies (weeks, months, years).</p>
</li>
<li>
<p><strong>Protection against cluster-level catastrophes</strong>: Namespace deletion, control plane failure, complete infrastructure loss.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Characteristics</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Off-cluster</strong>: Stored outside the Kubernetes cluster (different infrastructure).</p>
</li>
<li>
<p><strong>Durable</strong>: Survives cluster deletion, Longhorn uninstallation, or regional outages.</p>
</li>
<li>
<p><strong>Slower</strong>: Restore operations may take minutes to hours depending on data size.</p>
</li>
<li>
<p><strong>Long retention</strong>: Kept for weeks, months, or indefinitely.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Critical</strong>: Backups are your <strong>last line of defense</strong>. They&#8217;re the only mechanism that survives a complete cluster failure.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="how-ha-snapshots-and-backups-complement-each-other">How HA, Snapshots, and Backups Complement Each Other</h3>
<div class="paragraph">
<p>Each layer addresses different failure domains:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mechanism</th>
<th class="tableblock halign-left valign-top">Protects Against</th>
<th class="tableblock halign-left valign-top">Recovery Time</th>
<th class="tableblock halign-left valign-top">Retention</th>
<th class="tableblock halign-left valign-top">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>HA Replicas</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node/disk/AZ failure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instant (automatic)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always active</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Infrastructure only</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Snapshots</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Accidental changes, bad deployments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seconds to minutes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hours to days</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">In-cluster</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Backups</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster failure, disasters, compliance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Minutes to hours</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Weeks to years</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Off-cluster</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Together</strong>: HA keeps your service running, snapshots give you operational safety, and backups provide true disaster recovery.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="concrete-examples">Concrete Examples</h3>
<div class="paragraph">
<p><br></p>
</div>
<div class="sect3">
<h4 id="example-1-airflow-logs">Example 1: Airflow Logs</h4>
<div class="ulist">
<ul>
<li>
<p><strong>HA</strong>: Logs stay available if a node dies.</p>
</li>
<li>
<p><strong>Snapshot</strong>: Rarely useful (logs are append-only).</p>
</li>
<li>
<p><strong>Backup</strong>: Mostly unnecessary (logs are ephemeral and can be regenerated).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Conclusion</strong>: HA is sufficient; snapshots and backups are optional.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect3">
<h4 id="example-2-airflow-metadata-database">Example 2: Airflow Metadata Database</h4>
<div class="ulist">
<ul>
<li>
<p><strong>HA</strong>: Keeps the database running during node failures.</p>
</li>
<li>
<p><strong>Snapshot</strong>: Taken before schema migrations or major configuration changes.</p>
</li>
<li>
<p><strong>Backup</strong>: Recover from a failed migration, accidental data deletion, or cluster disaster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Conclusion</strong>: All three mechanisms are needed. This is mission-critical stateful data.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect3">
<h4 id="example-3-cicd-artifacts">Example 3: CI/CD Artifacts</h4>
<div class="ulist">
<ul>
<li>
<p><strong>HA</strong>: Ensures builds don&#8217;t fail due to node loss.</p>
</li>
<li>
<p><strong>Snapshot</strong>: Quick rollback after a bad pipeline deployment.</p>
</li>
<li>
<p><strong>Backup</strong>: Optional, with short retention (artifacts can often be regenerated).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Conclusion</strong>: HA + snapshots for operational stability; backups optional depending on regeneration cost.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect3">
<h4 id="example-4-platform-configuration-data">Example 4: Platform Configuration Data</h4>
<div class="paragraph">
<p><em>(Keycloak database, Argo CD state, internal tools)</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HA</strong>: Maintains uptime during infrastructure failures.</p>
</li>
<li>
<p><strong>Snapshot</strong>: Enables safe upgrades and testing.</p>
</li>
<li>
<p><strong>Backup</strong>: Required for disaster recovery and compliance (audit trails, user data).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Conclusion</strong>: All three are essential for production platforms.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="why-ha-only-is-dangerous">Why "HA Only" Is Dangerous</h3>
<div class="paragraph">
<p>Relying solely on HA replication exposes you to:</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<strong>Unrecoverable data loss</strong> from application bugs, human error, or malicious activity. Once data is corrupted or deleted, all replicas reflect that state immediately. Without snapshots or backups, there is no recovery path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Real-world failure scenarios that HA cannot protect against:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A developer runs <code>kubectl delete pvc</code> on the wrong namespace.</p>
</li>
<li>
<p>A database migration script has a bug and corrupts critical tables.</p>
</li>
<li>
<p>Ransomware encrypts application data.</p>
</li>
<li>
<p>A misconfigured application truncates a production database table.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>All of these scenarios propagate instantly to all HA replicas.</strong> Without snapshots or backups, your data is gone.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="practical-recommendations">Practical Recommendations</h3>
<div class="paragraph">
<p>A reasonable production approach:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Data Type</th>
<th class="tableblock halign-left valign-top">HA</th>
<th class="tableblock halign-left valign-top">Snapshots</th>
<th class="tableblock halign-left valign-top">Backups</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ Not needed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ Not needed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Metadata Database</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Before migrations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Daily or more</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User/Application Data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚠️ Recommended</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Daily or more</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CI/CD Cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ Not needed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ Not needed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Platform State</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Before upgrades</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Daily or more</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The exact snapshot and backup frequency depends on your RPO (Recovery Point Objective) and how much data loss is acceptable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="summary">Summary</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Even with fully HA replicas across multiple availability zones, snapshots and backups remain essential. HA protects availability during infrastructure failures, snapshots enable safe operations and fast rollback, and backups provide true disaster recovery. These mechanisms solve different problems and must be used together for production environments.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-1-create-an-aws-s3-bucket">Step 1: Create an AWS S3 Bucket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a dedicated S3 bucket for Longhorn backups:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Log in to the <strong>AWS Management Console</strong> and navigate to <strong>S3</strong>.</p>
</li>
<li>
<p>Click <strong>Create bucket</strong>.</p>
</li>
<li>
<p>Enter a unique <strong>Bucket name</strong> (e.g., <code>my-longhorn-backups-us-east-1</code>).</p>
<div class="ulist">
<ul>
<li>
<p>Use lowercase letters, numbers, and hyphens only.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Select an <strong>AWS Region</strong> close to your cluster (e.g., <code>us-east-1</code>).</p>
<div class="ulist">
<ul>
<li>
<p>For disaster recovery, consider a region different from your cluster location.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Leave <strong>Block all public access</strong> enabled.</p>
</li>
<li>
<p>Click <strong>Create bucket</strong>.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Note the <strong>Bucket Name</strong> and <strong>Region</strong> for later configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-2-create-an-aws-iam-user-and-policy">Step 2: Create an AWS IAM User and Policy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Longhorn needs permission to access the S3 bucket. It is best practice to create a dedicated IAM user with restricted permissions.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="2-1-create-an-iam-policy">2.1 Create an IAM Policy</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate to <strong>IAM</strong> in the AWS Console.</p>
</li>
<li>
<p>Click <strong>Policies</strong> &#8594; <strong>Create policy</strong>.</p>
</li>
<li>
<p>Select the <strong>JSON</strong> tab and paste the following policy (replace <code>&lt;your-bucket-name&gt;</code>):</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">LonghornS3BackupPolicy.json</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"Version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2012-10-17"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"Statement"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"Sid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"LonghornBackupAccess"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"Effect"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Allow"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"Action"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"s3:PutObject"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"s3:GetObject"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"s3:ListBucket"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"s3:DeleteObject"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"Resource"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"arn:aws:s3:::&lt;your-bucket-name&gt;"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"arn:aws:s3:::&lt;your-bucket-name&gt;/*"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click <strong>Next</strong>, name the policy <code>LonghornS3BackupPolicy</code>, and click <strong>Create policy</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="2-2-create-an-iam-user">2.2 Create an IAM User</h3>
<div class="paragraph">
<p>With the policy created, the next step is to create a dedicated IAM user that will use this policy. This user represents the "identity" that Longhorn will assume when interacting with S3.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In production environments, consider using <strong>IAM Roles for Service Accounts (IRSA)</strong> instead of IAM users with static credentials. IRSA provides temporary, automatically rotated credentials and is more secure than long-lived access keys. However, for simplicity and compatibility with all Kubernetes distributions, this guide uses IAM users. See the IRSA implementation guide for production-grade authentication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Detailed Steps:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Access IAM Users</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Navigate to <strong>Users</strong> in the IAM console.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Configure User Identity</strong>:</p>
</li>
<li>
<p><strong>Click Next</strong> to proceed to permissions.</p>
</li>
<li>
<p><strong>Attach the Policy</strong>:</p>
</li>
<li>
<p><strong>Review and Create</strong>:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="2-3-create-access-keys">2.3 Create Access Keys</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click on the newly created user to open user details.</p>
</li>
<li>
<p>Go to the <strong>Security credentials</strong> tab.</p>
</li>
<li>
<p>Under <strong>Access keys</strong>, click <strong>Create access key</strong>.</p>
</li>
<li>
<p>Select <strong>Third-party service</strong> &#8594; <strong>Next</strong> &#8594; <strong>Create access key</strong>.</p>
</li>
<li>
<p><strong>Save the Access key ID and Secret access key</strong> (you cannot retrieve the secret later).</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Never commit these credentials to Git. For production, consider IAM Roles for Service Accounts (IRSA) or rotate keys every 90 days.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-3-create-a-kubernetes-secret">Step 3: Create a Kubernetes Secret</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Store AWS credentials in a Kubernetes secret so Longhorn can access S3.</p>
</div>
<div class="sect2">
<h3 id="method-1-create-secret-using-kubectl">Method 1: Create Secret Using kubectl</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Set environment variables with your AWS credentials</span>
<span class="nb">export </span><span class="nv">S3_BACKUP_AWS_ACCESS_KEY_ID</span><span class="o">=</span><span class="s2">"your-access-key-id"</span>
<span class="nb">export </span><span class="nv">S3_BACKUP_AWS_SECRET_ACCESS_KEY</span><span class="o">=</span><span class="s2">"your-secret-access-key"</span>

<span class="c"># Create the secret in longhorn-system namespace</span>
kubectl create secret generic aws-s3-credentials <span class="se">\</span>
  <span class="nt">-n</span> longhorn-system <span class="se">\</span>
  <span class="nt">--from-literal</span><span class="o">=</span><span class="nv">AWS_ACCESS_KEY_ID</span><span class="o">=</span><span class="k">${</span><span class="nv">S3_BACKUP_AWS_ACCESS_KEY_ID</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">--from-literal</span><span class="o">=</span><span class="nv">AWS_SECRET_ACCESS_KEY</span><span class="o">=</span><span class="k">${</span><span class="nv">S3_BACKUP_AWS_SECRET_ACCESS_KEY</span><span class="k">}</span>

<span class="c"># Verify the secret was created</span>
kubectl get secret aws-s3-credentials <span class="nt">-n</span> longhorn-system

<span class="c"># Clean up environment variables</span>
<span class="nb">unset </span>S3_BACKUP_AWS_ACCESS_KEY_ID
<span class="nb">unset </span>S3_BACKUP_AWS_SECRET_ACCESS_KEY</code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="method-2-create-secret-using-yaml-recommended-for-gitops">Method 2: Create Secret Using YAML (Recommended for GitOps)</h3>
<div class="paragraph">
<p>For infrastructure-as-code workflows or when managing secrets declaratively, you can create a YAML manifest. <strong>However, never commit credentials directly to Git.</strong></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The example below contains plaintext credentials using <code>stringData</code>. In production GitOps workflows, use sealed secrets, external-secrets operator, or a similar tool to encrypt credentials before committing to Git.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Create a YAML file</strong> named <code>aws-creds.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="c1"># The secret name - must match what you configure in Longhorn backup target</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">aws-s3-backup-credentials</span>
  <span class="c1"># Must be in the longhorn-system namespace</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">longhorn-system</span>
<span class="c1"># Generic secrets use 'Opaque' type</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">Opaque</span>
<span class="c1"># Use 'stringData' for human-readable values (Kubernetes auto-converts to base64)</span>
<span class="na">stringData</span><span class="pi">:</span>
  <span class="c1"># AWS Access Key ID - identifies the IAM user</span>
  <span class="na">AWS_ACCESS_KEY_ID</span><span class="pi">:</span> <span class="s">&lt;YOUR_ACCESS_KEY_ID&gt;</span>
  <span class="c1"># AWS Secret Access Key - authenticates the IAM user</span>
  <span class="na">AWS_SECRET_ACCESS_KEY</span><span class="pi">:</span> <span class="s">&lt;YOUR_SECRET_ACCESS_KEY&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The keys <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> must be named exactly as shown. Longhorn expects these specific key names when reading S3 credentials.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><strong>Apply the Secret to Your Cluster</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Create the secret from the YAML file</span>
kubectl apply <span class="nt">-f</span> aws-creds.yaml

<span class="c"># Verify creation</span>
kubectl get secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Secure or Delete the YAML File</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Option 1: Delete the file immediately after creation</span>
<span class="nb">rm </span>aws-creds.yaml

<span class="c"># Option 2: If keeping for documentation, remove credential values</span>
<span class="c"># and add to .gitignore to prevent accidental commits</span>
<span class="nb">echo</span> <span class="s2">"aws-creds.yaml"</span> <span class="o">&gt;&gt;</span> .gitignore</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For production environments, consider using Kubernetes external-secrets operator, sealed-secrets, or AWS Secrets Manager integration to avoid storing plaintext credentials in YAML files.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-4-configure-longhorn-backup-target">Step 4: Configure Longhorn Backup Target</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Forward the Longhorn UI:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">kubectl port-forward <span class="nt">-n</span> longhorn-system svc/longhorn-frontend 8080:80</code></pre>
</div>
</div>
</li>
<li>
<p>Navigate to <strong>Backup and Restore</strong> &#8594; <strong>Backup Targets</strong>.</p>
</li>
<li>
<p>Click <strong>Edit</strong> on the default backup target.</p>
</li>
<li>
<p>Configure:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Backup Target</strong>: <code>s3://&lt;bucket-name&gt;@&lt;region&gt;/</code> (e.g., <code>s3://my-backup@us-east-1/</code>)</p>
</li>
<li>
<p><strong>Credential Secret</strong>: <code>aws-s3-credentials</code></p>
</li>
<li>
<p><strong>Poll Interval</strong>: <code>300</code> (5 minutes)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Click <strong>OK</strong> and verify the state shows "Ready".</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="step-5-verify-configuration">Step 5: Verify Configuration</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In Longhorn UI, go to <strong>Volume</strong> and select a test volume.</p>
</li>
<li>
<p>Click <strong>Snapshots and Backups</strong> tab.</p>
</li>
<li>
<p>Click <strong>Take Snapshot</strong> to create a test snapshot.</p>
</li>
<li>
<p>Once the snapshot appears, click <strong>Backup</strong> on that snapshot.</p>
</li>
<li>
<p>Monitor the backup progress - it should upload to S3.</p>
</li>
<li>
<p>Verify the backup appears in the <strong>Backup</strong> section.</p>
</li>
<li>
<p>(Optional) Check S3 directly:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">aws s3 <span class="nb">ls </span>s3://your-bucket-name/backups/ <span class="nt">--recursive</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Verify Backup in S3 Console</strong> (Optional but Recommended):</p>
<div class="ulist">
<ul>
<li>
<p>Log into the AWS S3 Console.</p>
</li>
<li>
<p>Navigate to your backup bucket (e.g., <code>my-longhorn-backups</code>).</p>
</li>
<li>
<p>You should see a directory structure created by Longhorn:</p>
<div class="listingblock">
<div class="content">
<pre>my-longhorn-backups/
├── backups/
│   └── &lt;volume-name&gt;/
│       ├── backup-&lt;timestamp&gt;.cfg  # Backup metadata
│       └── blocks/                 # Actual data blocks</pre>
</div>
</div>
</li>
<li>
<p>The presence of these files confirms that Longhorn successfully uploaded data to S3.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If the backup completes successfully in the Longhorn UI and you can see files in S3, your backup configuration is working correctly. This verification should be performed after initial setup and periodically thereafter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="troubleshooting">Troubleshooting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Backup configuration failures usually fall into one of three categories: permissions issues, network connectivity problems, or configuration errors. Here&#8217;s how to diagnose and fix the most common issues:</p>
</div>
<div class="sect2">
<h3 id="error-access-denied-or-aws-error-access-denied">Error: "Access Denied" or "AWS Error: Access Denied"</h3>
<div class="paragraph">
<p><strong>Symptom</strong>: Longhorn cannot connect to S3, or backup creation fails with an access denied error.</p>
</div>
<div class="paragraph">
<p><strong>Root Causes:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Incorrect IAM Policy</strong>: The policy doesn&#8217;t grant all required permissions.</p>
</li>
<li>
<p><strong>Wrong Bucket ARN</strong>: The policy references a different bucket than configured.</p>
</li>
<li>
<p><strong>Invalid Credentials</strong>: The access key or secret key is incorrect or has been rotated.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Resolution Steps:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Verify IAM Policy Permissions</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Use AWS CLI to check the user's attached policies</span>
aws iam list-attached-user-policies <span class="nt">--user-name</span> longhorn-backup-user

<span class="c"># Verify the policy has all four required permissions:</span>
<span class="c"># s3:PutObject, s3:GetObject, s3:ListBucket, s3:DeleteObject</span>
aws iam get-policy-version <span class="se">\</span>
  <span class="nt">--policy-arn</span> &lt;policy-arn-from-previous-command&gt; <span class="se">\</span>
  <span class="nt">--version-id</span> v1</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Verify Bucket Name in Policy</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Ensure the bucket name in the IAM policy <strong>exactly matches</strong> the actual S3 bucket name.</p>
</li>
<li>
<p>Check for typos, extra spaces, or case sensitivity issues (bucket names are case-sensitive).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Test Credentials Manually</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Extract credentials from the Kubernetes secret</span>
<span class="nv">AWS_ACCESS_KEY_ID</span><span class="o">=</span><span class="si">$(</span>kubectl get secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.data.AWS_ACCESS_KEY_ID}'</span> | <span class="nb">base64</span> <span class="nt">-d</span><span class="si">)</span>
<span class="nv">AWS_SECRET_ACCESS_KEY</span><span class="o">=</span><span class="si">$(</span>kubectl get secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.data.AWS_SECRET_ACCESS_KEY}'</span> | <span class="nb">base64</span> <span class="nt">-d</span><span class="si">)</span>

<span class="c"># Test listing the bucket using the credentials</span>
<span class="nv">AWS_ACCESS_KEY_ID</span><span class="o">=</span><span class="nv">$AWS_ACCESS_KEY_ID</span> <span class="se">\</span>
<span class="nv">AWS_SECRET_ACCESS_KEY</span><span class="o">=</span><span class="nv">$AWS_SECRET_ACCESS_KEY</span> <span class="se">\</span>
aws s3 <span class="nb">ls </span>s3://&lt;your-bucket-name&gt;/

<span class="c"># If this fails, the credentials or permissions are incorrect</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Recreate Secret with Correct Credentials</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>If credentials were rotated or incorrect, delete and recreate the secret:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">kubectl delete secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system
<span class="c"># Then recreate following Step 3 instructions</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="error-unable-to-list-s3-bucket-or-invalid-endpoint">Error: "Unable to List S3 Bucket" or "Invalid Endpoint"</h3>
<div class="paragraph">
<p><strong>Symptom</strong>: Longhorn reports that it cannot list or access the S3 bucket.</p>
</div>
<div class="paragraph">
<p><strong>Root Causes:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Region Mismatch</strong>: The region in the backup target URL doesn&#8217;t match the bucket&#8217;s actual region.</p>
</li>
<li>
<p><strong>Incorrect URL Format</strong>: The S3 URL is malformed.</p>
</li>
<li>
<p><strong>Bucket Doesn&#8217;t Exist</strong>: The bucket name is incorrect or the bucket was deleted.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Resolution Steps:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Verify Bucket Region</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Check the bucket's actual region</span>
aws s3api get-bucket-location <span class="nt">--bucket</span> &lt;your-bucket-name&gt;

<span class="c"># Output will be: {"LocationConstraint": "us-east-1"}</span>
<span class="c"># (Note: us-east-1 buckets may return null, which is correct)</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Verify Backup Target URL Format</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Correct format: <code>s3://&lt;bucket-name&gt;@&lt;region&gt;/</code></p>
</li>
<li>
<p>Common mistakes:</p>
<div class="ulist">
<ul>
<li>
<p>Missing <code>@</code> symbol: <code>s3://&lt;bucket-name&gt;/&lt;region&gt;/</code> ❌</p>
</li>
<li>
<p>Missing trailing <code>/</code>: <code>s3://&lt;bucket-name&gt;@&lt;region&gt;</code> ❌</p>
</li>
<li>
<p>Using ARN: <code>s3://arn:aws:s3:::&lt;bucket-name&gt;@&lt;region&gt;/</code> ❌</p>
</li>
<li>
<p>Wrong region: <code>s3://my-bucket@us-west-2/</code> when bucket is in <code>us-east-1</code> ❌</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Update Backup Target with Correct Region</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Edit the backup target in Longhorn UI with the correct region from step 1.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="error-backup-target-not-ready-or-secret-not-found">Error: "Backup Target Not Ready" or "Secret Not Found"</h3>
<div class="paragraph">
<p><strong>Symptom</strong>: The backup target shows as unavailable or Longhorn can&#8217;t find the credential secret.</p>
</div>
<div class="paragraph">
<p><strong>Root Causes:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Secret Doesn&#8217;t Exist</strong>: The secret wasn&#8217;t created or was created in the wrong namespace.</p>
</li>
<li>
<p><strong>Secret Name Mismatch</strong>: The secret name in Longhorn config doesn&#8217;t match the actual secret name.</p>
</li>
<li>
<p><strong>Wrong Namespace</strong>: The secret exists but not in <code>longhorn-system</code> namespace.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Resolution Steps:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Verify Secret Exists</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Check if secret exists in longhorn-system namespace</span>
kubectl get secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system

<span class="c"># If not found, verify it wasn't created in a different namespace</span>
kubectl get secrets <span class="nt">--all-namespaces</span> | <span class="nb">grep </span>aws-s3-backup-credentials</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Verify Secret Has Correct Keys</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># The secret must contain exactly these two keys:</span>
<span class="c"># - AWS_ACCESS_KEY_ID</span>
<span class="c"># - AWS_SECRET_ACCESS_KEY</span>
kubectl describe secret aws-s3-backup-credentials <span class="nt">-n</span> longhorn-system</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Recreate Secret in Correct Namespace</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>If the secret is in the wrong namespace or missing keys, delete and recreate it following Step 3.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="additional-troubleshooting-commands">Additional Troubleshooting Commands</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># View Longhorn manager logs for detailed error messages</span>
kubectl logs <span class="nt">-n</span> longhorn-system <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>longhorn-manager <span class="nt">--tail</span><span class="o">=</span>100

<span class="c"># Check backup controller logs specifically</span>
kubectl logs <span class="nt">-n</span> longhorn-system deploy/longhorn-manager <span class="nt">-c</span> longhorn-manager | <span class="nb">grep</span> <span class="nt">-i</span> backup

<span class="c"># Verify network connectivity from a pod to S3</span>
kubectl run <span class="nt">-it</span> <span class="nt">--rm</span> debug <span class="nt">--image</span><span class="o">=</span>amazon/aws-cli <span class="nt">--restart</span><span class="o">=</span>Never <span class="nt">--</span> <span class="se">\</span>
  s3 <span class="nb">ls </span>s3://&lt;your-bucket-name&gt;/ <span class="nt">--region</span> &lt;your-region&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most backup configuration issues can be resolved by carefully verifying: (1) IAM permissions, (2) bucket region, (3) secret existence and correctness, and (4) backup target URL format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-to-create-a-backup">How to Create a Backup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Understanding Longhorn&#8217;s backup architecture is key to effective data protection. Longhorn follows a snapshot-first approach: <strong>backups are always created from snapshots, not directly from live volumes</strong>. This design ensures data consistency by capturing a stable, point-in-time state before uploading to external storage.</p>
</div>
<div class="paragraph">
<p><strong>Why Snapshot-Based Backups?</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Consistency</strong>: Snapshots freeze the volume state at a specific moment, preventing data corruption from ongoing writes.</p>
</li>
<li>
<p><strong>Efficiency</strong>: Longhorn uses incremental snapshots, so only changed data blocks are stored.</p>
</li>
<li>
<p><strong>Flexibility</strong>: You can create multiple snapshots locally (fast) and selectively choose which ones to backup externally (slower but durable).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Backup Creation Workflow:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Snapshot Creation</strong>: Capture the current volume state as a local snapshot.</p>
</li>
<li>
<p><strong>Backup Upload</strong>: Upload the snapshot data to the configured backup target (S3, NFS, etc.).</p>
</li>
<li>
<p><strong>Metadata Storage</strong>: Store backup metadata in S3 for discovery and restoration.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are two approaches to creating backups: manual (on-demand) and automated (scheduled).</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="manual-backup-creation">Manual Backup Creation</h3>
<div class="paragraph">
<p>Manual backups are ideal for one-time backup needs, such as before major application upgrades, database migrations, or when testing new configurations. This gives you complete control over when backups are created.</p>
</div>
<div class="paragraph">
<p><strong>Detailed Workflow:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Navigate to Volume Management</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Open the Longhorn UI.</p>
</li>
<li>
<p>Click <strong>Volume</strong> in the top navigation menu.</p>
</li>
<li>
<p>You&#8217;ll see a list of all persistent volumes in your cluster.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Select Target Volume</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click on the name of the volume you want to back up (e.g., <code>pvc-abc123</code> or <code>postgres-data</code>).</p>
</li>
<li>
<p>This opens the volume detail page showing metadata, health status, and replicas.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Access Snapshot Management</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click on the <strong>Snapshots and Backups</strong> tab.</p>
</li>
<li>
<p>This shows all existing snapshots for this volume.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Create a Snapshot</strong> (if you need a new one):</p>
<div class="ulist">
<ul>
<li>
<p>Click the <strong>Take Snapshot</strong> button.</p>
</li>
<li>
<p><strong>Optional</strong>: Provide labels for easier identification:</p>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Descriptive name like <code>pre-migration-v2.0</code></p>
</li>
<li>
<p><code>purpose</code>: Context like <code>before-schema-change</code></p>
</li>
<li>
<p><code>created-by</code>: Your name or automation source</p>
</li>
</ul>
</div>
</li>
<li>
<p>Click <strong>OK</strong>.</p>
</li>
<li>
<p><strong>What happens</strong>: Longhorn creates a read-only, space-efficient copy of the volume&#8217;s current state. This happens in seconds and doesn&#8217;t interrupt the running application.</p>
</li>
<li>
<p>The snapshot appears in the snapshot list immediately.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Create a Backup from the Snapshot</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>In the snapshot list, locate the snapshot you want to back up.</p>
</li>
<li>
<p>Click the <strong>Create Backup</strong> button for that snapshot (may have a cloud/upload icon or appear in a dropdown menu).</p>
</li>
<li>
<p><strong>Optional</strong>: Add backup-specific labels for retention policies or compliance tracking:</p>
<div class="ulist">
<ul>
<li>
<p><code>retention</code>: <code>7-days</code>, <code>30-days</code>, <code>permanent</code></p>
</li>
<li>
<p><code>environment</code>: <code>production</code>, <code>staging</code></p>
</li>
<li>
<p><code>compliance</code>: <code>gdpr</code>, <code>hipaa</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Click <strong>OK</strong> to start the backup.</p>
</li>
<li>
<p><strong>What happens</strong>: Longhorn uploads the snapshot data to S3. Progress is shown in the UI. Depending on the volume size and network bandwidth, this can take from seconds to hours.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Monitor Backup Progress</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>The backup will show a progress indicator (percentage or status message).</p>
</li>
<li>
<p>You can navigate away—the backup continues in the background.</p>
</li>
<li>
<p>Once complete, the backup status changes to "Completed" with a timestamp.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Verify Backup Success</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click <strong>Backup and Restore</strong> in the top menu.</p>
</li>
<li>
<p>Select the <strong>Backups</strong> tab.</p>
</li>
<li>
<p>Under the <strong>Volume</strong> tab, find your volume.</p>
</li>
<li>
<p>Your backup should be listed with the correct timestamp, size, and labels.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Manual backups are perfect for critical moments like before database schema changes, application upgrades, or configuration modifications. Always verify the backup completed successfully before proceeding with risky operations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="automated-backup-recurring-job">Automated Backup (Recurring Job)</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In Longhorn UI, go to <strong>Volume</strong> and select the volume(s) to backup.</p>
</li>
<li>
<p>Click <strong>Create Recurring Job</strong>.</p>
</li>
<li>
<p>Configure:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Task</strong>: <code>Backup</code></p>
</li>
<li>
<p><strong>Schedule</strong>: Cron expression (e.g., <code>0 2 * * *</code> for daily at 2 AM UTC)</p>
</li>
<li>
<p><strong>Retain</strong>: Number of backups to keep (e.g., <code>7</code> for 7 days)</p>
</li>
<li>
<p><strong>Concurrency</strong>: <code>1</code></p>
</li>
<li>
<p><strong>Labels</strong> (Optional): <code>environment=production</code>, <code>scheduled=true</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Click <strong>Save</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Common Cron Schedules:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text">0 2 * * *      # Daily at 2:00 AM UTC
0 */6 * * *    # Every 6 hours
0 0 * * 0      # Weekly (Sunday at midnight)
0 3 * * 1-5    # Weekdays only at 3:00 AM
0 1 1 * *      # Monthly (1st day at 1:00 AM)</code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="making-changes-after-backup-example-postgresql-table-creation">Making Changes After Backup (Example: PostgreSQL Table Creation)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After creating a backup or snapshot, you may want to make changes to your application data to simulate real-world scenarios or test restore procedures. This example demonstrates creating a test table in PostgreSQL that you can use to verify restore operations later.</p>
</div>
<div class="paragraph">
<p><strong>Why This is Useful:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Restore Verification</strong>: After restoring from a backup, you can check whether this table exists or not to confirm you&#8217;re using the correct restore point.</p>
</li>
<li>
<p><strong>Point-in-Time Testing</strong>: By creating distinct data before and after snapshots/backups, you can validate that restores return to the expected state.</p>
</li>
<li>
<p><strong>Compliance Testing</strong>: Demonstrate that backup and restore procedures work correctly for audit purposes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Connecting to PostgreSQL:</strong></p>
</div>
<div class="paragraph">
<p>First, connect to your PostgreSQL pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Connect to the PostgreSQL pod (adjust pod name and namespace as needed)</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> postgresql-0 <span class="nt">-n</span> service-foundry <span class="nt">--</span> psql <span class="nt">-U</span> postgres

<span class="c"># Or specify a specific database</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> postgresql-0 <span class="nt">-n</span> service-foundry <span class="nt">--</span> psql <span class="nt">-U</span> postgres <span class="nt">-d</span> mydatabase</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>SQL Commands to Create Test Data:</strong></p>
</div>
<div class="paragraph">
<p>Run the following SQL commands within the PostgreSQL session to create a table and insert test data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Create a test table for backup/restore verification</span>
<span class="c1">-- IF NOT EXISTS prevents errors if the table already exists from a previous test</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="k">public</span><span class="p">.</span><span class="n">users_for_backup_testing</span>
<span class="p">(</span>
    <span class="c1">-- User's full name (variable-length string up to 120 characters)</span>
    <span class="n">name</span> <span class="nb">character</span> <span class="nb">varying</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="nv">"default"</span><span class="p">,</span>

    <span class="c1">-- User's email address (variable-length string up to 120 characters)</span>
    <span class="n">email</span> <span class="nb">character</span> <span class="nb">varying</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">pg_catalog</span><span class="p">.</span><span class="nv">"default"</span>
<span class="p">);</span>

<span class="c1">-- Insert sample data for verification</span>
<span class="c1">-- After restore, you can query this table to see if you're at the correct point in time</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users_for_backup_testing</span>
<span class="k">VALUES</span>
    <span class="c1">-- Sample user 1</span>
    <span class="p">(</span><span class="s1">'kim'</span><span class="p">,</span> <span class="s1">'kim@company.com'</span><span class="p">),</span>

    <span class="c1">-- Sample user 2</span>
    <span class="p">(</span><span class="s1">'lee'</span><span class="p">,</span> <span class="s1">'lee@company.com'</span><span class="p">);</span>

<span class="c1">-- Verify the data was inserted correctly</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Expected Output:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="text"> name |       email
------+--------------------
 kim  | kim@company.com
 lee  | lee@company.com
(2 rows)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Using This for Restore Testing:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Before backup</strong>: Run these SQL commands to create the table with 2 rows.</p>
</li>
<li>
<p><strong>Create backup</strong>: Create a snapshot and backup using Longhorn.</p>
</li>
<li>
<p><strong>After backup</strong>: Add more data or modify the table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- Add data AFTER the backup</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users_for_backup_testing</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'park'</span><span class="p">,</span> <span class="s1">'park@company.com'</span><span class="p">);</span>

<span class="c1">-- Now the table has 3 rows</span>
<span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span><span class="p">;</span>  <span class="c1">-- Should return 3</span></code></pre>
</div>
</div>
</li>
<li>
<p><strong>Restore from backup</strong>: Follow the restore procedures in the next section.</p>
</li>
<li>
<p><strong>Verify restore</strong>: After restoration, query the table:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- If restore was successful, you should see only the original 2 rows</span>
<span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span><span class="p">;</span>  <span class="c1">-- Should return 2</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span><span class="p">;</span>  <span class="c1">-- Should NOT include 'park'</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use different table names or column values for different test scenarios. For example, add a <code>created_at</code> timestamp column to precisely identify when data was inserted relative to snapshots and backups.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="restore-from-snapshot">Restore from Snapshot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Longhorn snapshots provide the fastest path to recovery from operational mistakes, bad deployments, or data corruption. Because snapshots are stored <strong>locally within the cluster</strong>, restoration happens in seconds to minutes rather than hours. This makes snapshots ideal for quick rollback scenarios.</p>
</div>
<div class="paragraph">
<p><strong>When to Use Snapshot Restore:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Immediately after a bad application deployment</p>
</li>
<li>
<p>Following accidental data deletion or corruption</p>
</li>
<li>
<p>After a failed database migration</p>
</li>
<li>
<p>When testing changes before committing to production</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Important Limitations:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Snapshots only exist within your cluster—if the cluster is lost, snapshots are lost too</p>
</li>
<li>
<p>Snapshots cannot be used for cross-cluster migrations</p>
</li>
<li>
<p>They don&#8217;t protect against cluster-wide failures</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are two methods for restoring from snapshots, each suited to different scenarios.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="method-1-revert-to-snapshot-in-place-restore">Method 1: Revert to Snapshot (In-Place Restore)</h3>
<div class="paragraph">
<p>This method <strong>overwrites</strong> the existing volume with data from a previous snapshot. It&#8217;s the fastest restoration method but is destructive—any changes made after the snapshot was taken are permanently lost.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This operation is <strong>irreversible</strong>. All data written to the volume after the snapshot was taken will be <strong>permanently deleted</strong>. Always verify you&#8217;re reverting to the correct snapshot before proceeding.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>When to Use In-Place Revert:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You&#8217;re certain the current data is corrupted or unwanted</p>
</li>
<li>
<p>Fast recovery is critical (seconds vs. minutes)</p>
</li>
<li>
<p>You don&#8217;t need to inspect the restored data before committing</p>
</li>
<li>
<p>The application can tolerate brief downtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Detailed Workflow:</strong></p>
</div>
<div class="paragraph">
<p><strong>Step 1: Prepare Environment Variables</strong></p>
</div>
<div class="paragraph">
<p>Set up variables for easier command execution and to avoid typos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Application configuration</span>
<span class="nv">APP_NAME</span><span class="o">=</span>postgresql-app           <span class="c"># ArgoCD application name</span>
<span class="nv">NAMESPACE</span><span class="o">=</span>service-foundry         <span class="c"># Kubernetes namespace where app is deployed</span>

<span class="c"># Workload details</span>
<span class="nv">STATEFULSET_NAME</span><span class="o">=</span>postgresql       <span class="c"># StatefulSet managing the pod</span>
<span class="nv">POD_NAME</span><span class="o">=</span>postgresql-0             <span class="c"># Pod name (StatefulSet pods are predictable)</span>

<span class="c"># Storage details</span>
<span class="nv">PVC_NAME</span><span class="o">=</span>data-postgresql-0        <span class="c"># PVC name (matches StatefulSet volume claim template)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Step 2: Disable ArgoCD Auto-Sync (If Using ArgoCD)</strong></p>
</div>
<div class="paragraph">
<p>If your application is managed by ArgoCD, you must disable auto-sync to prevent ArgoCD from recreating resources you&#8217;re intentionally scaling down:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Remove sync policy (disables automated sync and self-healing)</span>
<span class="c"># This prevents ArgoCD from interfering with manual operations</span>
kubectl patch application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="se">\</span>
  <span class="nt">--type</span> merge <span class="se">\</span>
  <span class="nt">-p</span> <span class="s1">'{"spec":{"syncPolicy":null}}'</span>

<span class="c"># Verify sync policy was removed</span>
kubectl get application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.syncPolicy}'</span>
<span class="c"># Should output empty or null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Step 3: Stop the Application</strong></p>
</div>
<div class="paragraph">
<p>The volume must be detached before reverting. Scale down the application to zero replicas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Scale down StatefulSet to 0 replicas</span>
<span class="c"># This gracefully shuts down pods and detaches the PVC</span>
kubectl scale statefulset <span class="k">${</span><span class="nv">STATEFULSET_NAME</span><span class="k">}</span> <span class="nt">--replicas</span><span class="o">=</span>0 <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Wait for pod termination (timeout after 60 seconds)</span>
kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span>delete pod/<span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--timeout</span><span class="o">=</span>60s

<span class="c"># Verify no pods are running</span>
kubectl get pods <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span><span class="k">${</span><span class="nv">STATEFULSET_NAME</span><span class="k">}</span>
<span class="c"># Should show no pods or "No resources found"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Step 4: Revert to Snapshot in Longhorn UI</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Navigate to Volume Management</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Open the Longhorn UI.</p>
</li>
<li>
<p>Click <strong>Volume</strong> in the top navigation.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Select the Target Volume</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Find the volume corresponding to your PVC (usually named <code>pvc-&lt;uid&gt;</code>).</p>
</li>
<li>
<p>If unsure which volume corresponds to which PVC, run:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Find the Longhorn volume name for your PVC</span>
kubectl get pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.volumeName}'</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Verify Volume State</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click on the volume name to open details.</p>
</li>
<li>
<p>Check that the <strong>State</strong> is <strong>Detached</strong>.</p>
</li>
<li>
<p>If still "Attached", wait a few more seconds or verify pods are fully terminated.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Enable Maintenance Mode</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click the <strong>Attach</strong> button (or <strong>Attach Volume</strong> in the dropdown).</p>
</li>
<li>
<p><strong>Enable "Maintenance Mode"</strong> checkbox.</p>
</li>
<li>
<p>Maintenance mode attaches the volume in read-write mode without mounting it to a node, allowing safe revert operations.</p>
</li>
<li>
<p>Click <strong>OK</strong> to attach in maintenance mode.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Access Snapshot Management</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Click the <strong>Snapshots and Backups</strong> tab.</p>
</li>
<li>
<p>You&#8217;ll see a list of all snapshots for this volume.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Select and Revert Snapshot</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Locate the snapshot you want to revert to (check timestamp and labels carefully).</p>
</li>
<li>
<p>Click the <strong>Revert</strong> button or icon for that snapshot.</p>
</li>
<li>
<p><strong>Read the confirmation dialog carefully</strong>—this operation cannot be undone.</p>
</li>
<li>
<p>Confirm the revert operation.</p>
</li>
<li>
<p><strong>What happens</strong>: Longhorn overwrites the current volume data with the snapshot data. This typically completes in seconds to minutes depending on volume size.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Detach the Volume</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Once revert completes, the volume is still attached in maintenance mode.</p>
</li>
<li>
<p>Click <strong>Detach</strong> to release the volume.</p>
</li>
<li>
<p>Wait for the state to change back to <strong>Detached</strong>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Step 5: Restart the Application</strong></p>
</div>
<div class="paragraph">
<p>With the volume now containing the restored snapshot data, restart the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Scale StatefulSet back to 1 replica</span>
<span class="c"># The pod will mount the PVC, which now contains the reverted data</span>
kubectl scale statefulset <span class="k">${</span><span class="nv">STATEFULSET_NAME</span><span class="k">}</span> <span class="nt">--replicas</span><span class="o">=</span>1 <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Wait for pod to be ready (timeout after 300 seconds)</span>
kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span><span class="nv">condition</span><span class="o">=</span>ready pod/<span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--timeout</span><span class="o">=</span>300s

<span class="c"># Verify pod is running</span>
kubectl get pod <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Step 6: Re-enable ArgoCD Auto-Sync (If Applicable)</strong></p>
</div>
<div class="paragraph">
<p>Restore ArgoCD automated sync and self-healing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Re-enable automated sync with prune and self-heal</span>
kubectl patch application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="se">\</span>
  <span class="nt">--type</span> merge <span class="se">\</span>
  <span class="nt">-p</span> <span class="s1">'{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'</span>

<span class="c"># Verify sync policy was restored</span>
kubectl get application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.syncPolicy}'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<strong>Step 7: Verify Data Restoration</strong></p>
</div>
<div class="paragraph">
<p>Confirm the data matches the expected snapshot state:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># For PostgreSQL example:</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--</span> psql <span class="nt">-U</span> postgres <span class="nt">-c</span> <span class="s2">"
  SELECT count(*) FROM users_for_backup_testing;
"</span>
<span class="c"># Should show 2 if you're testing with the earlier example data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Use Cases:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Quick rollback</strong> after a bad deployment or configuration change</p>
</li>
<li>
<p><strong>Undo accidental data changes</strong> (e.g., wrong DELETE query executed)</p>
</li>
<li>
<p><strong>Restore to pre-upgrade state</strong> after a failed application or database upgrade</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="method-2-create-volume-from-snapshot-clone-and-test">Method 2: Create Volume from Snapshot (Clone and Test)</h3>
<div class="paragraph">
<p>Clone a snapshot to create a new volume without affecting the original:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In Longhorn UI, go to <strong>Volume</strong> and select the source volume.</p>
</li>
<li>
<p>Click <strong>Snapshots and Backups</strong> tab.</p>
</li>
<li>
<p>Click on a snapshot &#8594; <strong>Clone Volume</strong>.</p>
</li>
<li>
<p>Enter a name for the new volume (e.g., <code>postgres-data-restored</code>).</p>
</li>
<li>
<p>Click <strong>OK</strong>.</p>
</li>
<li>
<p>Select the new volume &#8594; <strong>Create PV/PVC</strong>.</p>
</li>
<li>
<p>Configure PVC name and namespace &#8594; <strong>OK</strong>.</p>
</li>
<li>
<p>Verify:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">kubectl get pvc data-postgresql-restored <span class="nt">-n</span> service-foundry</code></pre>
</div>
</div>
</li>
<li>
<p>(Optional) Test the cloned data before replacing production PVC.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replacing PVCs in StatefulSets requires deleting and recreating the StatefulSet or manually swapping PVCs. For complex scenarios, consult Longhorn volume migration documentation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Use Cases:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Testing restored data</strong> before committing to production use</p>
</li>
<li>
<p><strong>Creating development/staging environments</strong> from production snapshots</p>
</li>
<li>
<p><strong>Keeping the original data</strong> as a safety net during risky operations</p>
</li>
<li>
<p><strong>Comparing current vs. previous data</strong> for debugging or auditing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="snapshot-vs-backup-when-to-use-each">Snapshot vs Backup: When to Use Each</h3>
<div class="paragraph">
<p>Understanding when to use snapshots versus backups is crucial:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Aspect</th>
<th class="tableblock halign-left valign-top">Snapshot Restore</th>
<th class="tableblock halign-left valign-top">Backup Restore</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Speed</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Very fast (seconds)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Slower (minutes to hours)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Location</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">In-cluster only</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">External storage (S3, NFS)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Storage</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local Longhorn storage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Off-cluster backup target</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Survives cluster deletion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Cross-cluster restore</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌ No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅ Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Use Case</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operational rollbacks, testing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disaster recovery, long-term retention</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>When to Use</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Before upgrades, quick undo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DR, compliance, cluster migration</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="best-practices">Best Practices</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Use snapshots</strong> for:</p>
<div class="ulist">
<ul>
<li>
<p>Pre-upgrade safety nets</p>
</li>
<li>
<p>Quick operational rollbacks</p>
</li>
<li>
<p>Testing changes before committing</p>
</li>
<li>
<p>Frequent checkpoints (hourly/daily)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Use backups</strong> for:</p>
<div class="ulist">
<ul>
<li>
<p>Disaster recovery</p>
</li>
<li>
<p>Long-term retention (weeks/months)</p>
</li>
<li>
<p>Cross-cluster migrations</p>
</li>
<li>
<p>Compliance requirements</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Combined approach</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Take a snapshot before risky operations</p>
</li>
<li>
<p>Schedule regular backups to external storage</p>
</li>
<li>
<p>Test restore procedures regularly</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Snapshots are your first line of defense for operational mistakes. Backups are your last line of defense for catastrophic failures.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="restoring-from-backup">Restoring from Backup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Backup restoration is fundamentally different from snapshot restoration. While snapshots provide quick, in-cluster recovery, backups enable <strong>cross-cluster restoration</strong> and <strong>disaster recovery</strong> from complete cluster failures. When you restore a backup, Longhorn downloads data from your S3 bucket (or other backup target) and creates a new volume in your cluster.</p>
</div>
<div class="paragraph">
<p><strong>When to Use Backup Restore:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Disaster recovery</strong>: Your cluster has been completely lost or corrupted</p>
</li>
<li>
<p><strong>Cross-cluster migration</strong>: Moving data to a different Kubernetes cluster</p>
</li>
<li>
<p><strong>Long-term recovery</strong>: Restoring data from weeks or months ago (beyond snapshot retention)</p>
</li>
<li>
<p><strong>Cluster rebuild</strong>: Recreating volumes after infrastructure replacement</p>
</li>
<li>
<p><strong>Compliance</strong>: Recovering data for audit or regulatory requirements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Key Differences from Snapshot Restore:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Source</strong>: Data comes from external storage (S3), not local cluster storage</p>
</li>
<li>
<p><strong>Speed</strong>: Slower due to network transfer from S3 (minutes to hours)</p>
</li>
<li>
<p><strong>Availability</strong>: Works even if the original cluster no longer exists</p>
</li>
<li>
<p><strong>New Volume</strong>: Always creates a new volume—cannot revert an existing volume in-place</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="basic-backup-restore-workflow">Basic Backup Restore Workflow</h3>
<div class="paragraph">
<p>Restoring a backup is a multi-step process that involves downloading data from S3 and integrating it into your cluster.</p>
</div>
<div class="paragraph">
<p><strong>Step-by-Step Process:</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Access Backup Listing</strong>:</p>
</li>
<li>
<p><strong>Select Backup to Restore</strong>:</p>
</li>
<li>
<p><strong>Initiate Restore Operation</strong>:</p>
</li>
<li>
<p><strong>Configure Restore Options</strong>:</p>
</li>
<li>
<p><strong>Monitor Restore Progress</strong>:</p>
</li>
<li>
<p><strong>Verify Restore Completion</strong>:</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>Always stop applications</strong> using the original PVC before performing a replace-in-place restore. Restoring while the application is running can cause data corruption or restore failures.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="restoring-postgresql-with-argocd-management">Restoring PostgreSQL with ArgoCD Management</h3>
<div class="paragraph">
<p>When your application is managed by ArgoCD (or any GitOps tool), you must carefully coordinate the restore process to prevent ArgoCD from interfering with manual operations. ArgoCD&#8217;s automated sync and self-healing features will attempt to recreate resources you&#8217;re deliberately modifying, so they must be temporarily disabled.</p>
</div>
<div class="paragraph">
<p><strong>Why This is Necessary:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>ArgoCD monitors Git as the source of truth</p>
</li>
<li>
<p>When it detects drift (e.g., scaled-down pods, deleted PVCs), it auto-heals by recreating resources</p>
</li>
<li>
<p>During restore, you need manual control over resource lifecycles</p>
</li>
<li>
<p>After restore completes, you re-enable ArgoCD to resume normal operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect3">
<h4 id="step-by-step-restore-procedure">Step-by-Step Restore Procedure</h4>
<div class="paragraph">
<p>This procedure demonstrates replacing an existing PostgreSQL PVC with restored backup data:</p>
</div>
<div class="paragraph">
<p><strong>Step 1: Prepare Environment Variables</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Define application and infrastructure details</span>
<span class="c"># Adjust these values to match your environment</span>

<span class="nv">APP_NAME</span><span class="o">=</span>postgresql-app           <span class="c"># ArgoCD application name</span>
<span class="nv">NAMESPACE</span><span class="o">=</span>service-foundry         <span class="c"># Kubernetes namespace</span>
<span class="nv">STATEFULSET_NAME</span><span class="o">=</span>postgresql       <span class="c"># StatefulSet name</span>
<span class="nv">POD_NAME</span><span class="o">=</span>postgresql-0             <span class="c"># Primary pod name</span>
<span class="nv">PVC_NAME</span><span class="o">=</span>data-postgresql-0        <span class="c"># PersistentVolumeClaim name</span>

<span class="nv">APP_NAME</span><span class="o">=</span>postgresql-app
<span class="nv">NAMESPACE</span><span class="o">=</span>service-foundry
<span class="nv">STATEFULSET_NAME</span><span class="o">=</span>postgresql
<span class="nv">POD_NAME</span><span class="o">=</span>postgresql-0
<span class="nv">PVC_NAME</span><span class="o">=</span>data-postgresql-0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 2: Disable ArgoCD Auto-Sync</strong></p>
</div>
<div class="paragraph">
<p>Temporarily suspend ArgoCD&#8217;s automated operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Option A: Using ArgoCD CLI (if installed)</span>
<span class="c"># This sets sync policy to 'none', disabling automated sync</span>
argocd app <span class="nb">set</span> <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">--sync-policy</span> none

<span class="c"># Option B: Using kubectl (works without ArgoCD CLI)</span>
<span class="c"># Removes the entire syncPolicy section from the Application spec</span>
kubectl patch application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="se">\</span>
  <span class="nt">--type</span> merge <span class="se">\</span>
  <span class="nt">-p</span> <span class="s1">'{"spec":{"syncPolicy":null}}'</span>

<span class="c"># Verify sync policy was removed</span>
kubectl get application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.syncPolicy}'</span>
<span class="c"># Should output: (empty) or null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 3: Stop the Application</strong></p>
</div>
<div class="paragraph">
<p>Gracefully shut down PostgreSQL to ensure no data is being written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Scale StatefulSet to zero replicas</span>
<span class="c"># This terminates pods and releases the PVC</span>
kubectl scale statefulset <span class="k">${</span><span class="nv">STATEFULSET_NAME</span><span class="k">}</span> <span class="nt">--replicas</span><span class="o">=</span>0 <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Wait for pod deletion with timeout</span>
<span class="c"># This ensures the PVC is fully detached before proceeding</span>
kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span>delete pod/<span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--timeout</span><span class="o">=</span>60s

<span class="c"># Confirm no pods are running</span>
kubectl get pods <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">-l</span> app.kubernetes.io/name<span class="o">=</span>postgresql
<span class="c"># Expected: No resources found (or empty list)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 4: Remove Existing PVC and PV</strong></p>
</div>
<div class="paragraph">
<p>Delete the current PVC to make room for the restored one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Get the PV name before deleting PVC (you'll need to delete it too)</span>
<span class="nv">PV_NAME</span><span class="o">=</span><span class="si">$(</span>kubectl get pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.volumeName}'</span><span class="si">)</span>

<span class="nb">echo</span> <span class="s2">"PVC: </span><span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"PV:  </span><span class="k">${</span><span class="nv">PV_NAME</span><span class="k">}</span><span class="s2">"</span>

<span class="c"># Delete the PVC</span>
<span class="c"># Warning: This removes the PVC but the underlying Longhorn volume may still exist</span>
kubectl delete pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Wait for PVC deletion to complete</span>
kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span>delete pvc/<span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--timeout</span><span class="o">=</span>60s

<span class="c"># Delete the associated PV</span>
<span class="c"># This is necessary because PVs may have retain policy and won't auto-delete</span>
kubectl delete pv <span class="k">${</span><span class="nv">PV_NAME</span><span class="k">}</span>

<span class="c"># Verify deletion</span>
kubectl get pvc,pv <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> | <span class="nb">grep</span> <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span>
<span class="c"># Should return no results</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 5: Restore Backup in Longhorn UI</strong></p>
</div>
<div class="paragraph">
<p>Perform the restore operation through the Longhorn UI:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate to <strong>Backup and Restore</strong> → <strong>Backups</strong></p>
</li>
<li>
<p>Under the <strong>Volume</strong> tab, find your PostgreSQL volume backups</p>
</li>
<li>
<p>Select the backup you want to restore (verify timestamp and labels)</p>
</li>
<li>
<p>Click <strong>Restore</strong></p>
</li>
<li>
<p>In the restore dialog:</p>
<div class="ulist">
<ul>
<li>
<p><strong>PVC Name</strong>: Enter <code>data-postgresql-0</code> (the EXACT SAME name as the deleted PVC)</p>
</li>
<li>
<p><strong>Namespace</strong>: Select <code>service-foundry</code> (or your namespace)</p>
</li>
<li>
<p><strong>Storage Class</strong>: Leave as <code>longhorn</code> (default)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Click <strong>OK</strong> to initiate the restore</p>
</li>
<li>
<p><strong>Monitor progress</strong>: The restore shows up in the volume list with a progress indicator</p>
</li>
<li>
<p><strong>Wait for completion</strong>: Status changes to "Healthy" or "Bound" when done</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Step 6: Verify Restored PVC</strong></p>
</div>
<div class="paragraph">
<p>Confirm the PVC was created successfully:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Check PVC status</span>
kubectl get pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Expected output:</span>
<span class="c"># NAME                  STATUS   VOLUME           CAPACITY   ACCESS MODES   STORAGECLASS</span>
<span class="c"># data-postgresql-0     Bound    pvc-xyz...       10Gi       RWO            longhorn</span>

<span class="c"># Verify the PVC is bound to a Longhorn volume</span>
kubectl describe pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 7: Restart the Application</strong></p>
</div>
<div class="paragraph">
<p>Bring PostgreSQL back online with the restored data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Scale StatefulSet back to 1 replica</span>
<span class="c"># The pod mounts the restored PVC automatically</span>
kubectl scale statefulset <span class="k">${</span><span class="nv">STATEFULSET_NAME</span><span class="k">}</span> <span class="nt">--replicas</span><span class="o">=</span>1 <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>

<span class="c"># Wait for pod to become ready</span>
kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span><span class="nv">condition</span><span class="o">=</span>ready pod/<span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--timeout</span><span class="o">=</span>300s

<span class="c"># Check pod status</span>
kubectl get pod <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>
<span class="c"># Expected: STATUS = Running, READY = 1/1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Step 8: Re-enable ArgoCD Auto-Sync</strong></p>
</div>
<div class="paragraph">
<p>Restore automated GitOps management:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Option A: Using ArgoCD CLI</span>
argocd app <span class="nb">set</span> <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">--sync-policy</span> automated

<span class="c"># Option B: Using kubectl with full configuration</span>
<span class="c"># Re-enables automated sync with prune (delete orphaned resources)</span>
<span class="c"># and selfHeal (auto-correct drift)</span>
kubectl patch application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="se">\</span>
  <span class="nt">--type</span> merge <span class="se">\</span>
  <span class="nt">-p</span> <span class="s1">'{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'</span>

<span class="c"># Verify sync policy was restored</span>
kubectl get application <span class="k">${</span><span class="nv">APP_NAME</span><span class="k">}</span> <span class="nt">-n</span> argocd <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.syncPolicy}'</span>
<span class="c"># Should output: {"automated":{"prune":true,"selfHeal":true}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect3">
<h4 id="data-verification-after-restore">Data Verification After Restore</h4>
<div class="paragraph">
<p>After successfully restoring and restarting your application, thorough verification is critical to ensure data integrity and completeness.</p>
</div>
<div class="paragraph">
<p><strong>Comprehensive Verification Checklist:</strong></p>
</div>
<div class="paragraph">
<p><strong>1. Verify Infrastructure Components:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Check PVC is bound to a volume</span>
kubectl get pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>
<span class="c"># STATUS should be "Bound"</span>

<span class="c"># Verify PV exists and matches the PVC</span>
kubectl get pv <span class="si">$(</span>kubectl get pvc <span class="k">${</span><span class="nv">PVC_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.volumeName}'</span><span class="si">)</span>

<span class="c"># Check PostgreSQL pod is running and ready</span>
kubectl get pod <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span>
<span class="c"># STATUS = Running, READY = 1/1</span>

<span class="c"># View recent pod logs to check for startup errors</span>
kubectl logs <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--tail</span><span class="o">=</span>50
<span class="c"># Look for successful startup messages, no errors</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Verify PostgreSQL Connectivity:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Test database connection</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--</span> psql <span class="nt">-U</span> postgres <span class="nt">-c</span> <span class="s2">"SELECT version();"</span>

<span class="c"># Should return PostgreSQL version information without errors</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. Verify Data Integrity:</strong></p>
</div>
<div class="paragraph">
<p>Connect to PostgreSQL and perform data validation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Open interactive PostgreSQL session</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--</span> psql <span class="nt">-U</span> postgres</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside the PostgreSQL prompt, run verification queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="c1">-- List all databases (verify expected databases exist)</span>
<span class="err">\</span><span class="n">l</span>

<span class="c1">-- Connect to your application database</span>
<span class="err">\</span><span class="k">c</span> <span class="o">&lt;</span><span class="n">your</span><span class="o">-</span><span class="k">database</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>

<span class="c1">-- List all tables (verify schema is intact)</span>
<span class="err">\</span><span class="n">dt</span>

<span class="c1">-- Verify row counts for critical tables</span>
<span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span><span class="p">;</span>
<span class="c1">-- Compare against expected counts from before the incident</span>

<span class="c1">-- Check for recent data (if applicable)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">-- Verify specific records that should exist in the backup</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users_for_backup_testing</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'kim'</span><span class="p">,</span> <span class="s1">'lee'</span><span class="p">);</span>
<span class="c1">-- Should return the expected test data</span>

<span class="c1">-- Exit PostgreSQL</span>
<span class="err">\</span><span class="n">q</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>4. Verify Application Functionality:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># If your application has a health check endpoint</span>
kubectl <span class="nb">exec</span> <span class="k">${</span><span class="nv">POD_NAME</span><span class="k">}</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">NAMESPACE</span><span class="k">}</span> <span class="nt">--</span> curl http://localhost:5432

<span class="c"># Or test application-level queries</span>
<span class="c"># (connect through your application and verify it can read/write data)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>5. Check Longhorn Volume Metadata:</strong></p>
</div>
<div class="paragraph">
<p>Verify the volume was properly restored from backup:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open Longhorn UI</p>
</li>
<li>
<p>Navigate to <strong>Volume</strong> page</p>
</li>
<li>
<p>Find the restored volume (named <code>pvc-&lt;uid&gt;</code>)</p>
</li>
<li>
<p>Click to open details</p>
</li>
<li>
<p>Go to <strong>Snapshots and Backups</strong> tab</p>
</li>
<li>
<p>Check the <strong>Restored From</strong> timestamp or metadata</p>
</li>
<li>
<p>Verify it matches the backup you intended to restore</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>Best Practice</strong>: Always test restores in a non-production environment first. Consider keeping the old PVC for a few days as insurance before permanently deleting it. Create a test namespace, restore there, verify fully, then restore to production.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deleting-snapshots-and-backups">Deleting Snapshots and Backups</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Regular cleanup of old snapshots and backups is essential for managing storage costs and maintaining system performance. However, deletion must be done carefully to avoid accidentally removing data you might need for recovery.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="sect2">
<h3 id="deleting-snapshots">Deleting Snapshots</h3>
<div class="paragraph">
<p>Snapshots consume space within your Longhorn cluster. Old or unnecessary snapshots should be removed to free up storage, but be cautious—once deleted, they cannot be recovered.</p>
</div>
<div class="paragraph">
<p><strong>When to Delete Snapshots:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>After creating a successful backup (the backup preserves the snapshot data externally)</p>
</li>
<li>
<p>When snapshots exceed your retention policy (e.g., keeping only the last 7 days)</p>
</li>
<li>
<p>After confirming a risky operation succeeded and rollback is no longer needed</p>
</li>
<li>
<p>When cluster storage is running low and snapshots are consuming significant space</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<strong>Do not delete snapshots that haven&#8217;t been backed up</strong> if you need long-term retention. Snapshots are your only local recovery point—once deleted, you can only restore from external backups.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Automated Cleanup:</strong></p>
</div>
<div class="paragraph">
<p>Longhorn supports automatic snapshot cleanup through recurring job retention policies. When you configure a recurring backup job with a retention count (e.g., retain 7 backups), Longhorn automatically deletes older snapshots and backups when new ones are created.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Before deleting a snapshot, verify that a corresponding backup exists in S3 (if you need long-term retention). Check the <strong>Backup</strong> tab to confirm.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
<div class="sect2">
<h3 id="deleting-backups">Deleting Backups</h3>
<div class="paragraph">
<p>Backups stored in S3 (or other external targets) consume cloud storage and incur costs. Removing old backups reduces these costs but should align with your retention policy and compliance requirements.</p>
</div>
<div class="paragraph">
<p><strong>When to Delete Backups:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Backups older than your retention policy (e.g., keeping only 30 days)</p>
</li>
<li>
<p>Test backups created during development or validation</p>
</li>
<li>
<p>Backups from decommissioned volumes or applications</p>
</li>
<li>
<p>When migrating to a new backup strategy or storage location</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Important Considerations:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Backups may be required for compliance (GDPR, HIPAA, SOX, etc.)</p>
</li>
<li>
<p>Coordinate with legal/compliance teams before deleting long-term backups</p>
</li>
<li>
<p>Backups are your disaster recovery insurance—excessive deletion increases risk</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<strong>Backups are immutable once created</strong>. There is no "undo" for backup deletion. Always verify you&#8217;re deleting the correct backup and that you have other recovery options if needed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Implement a backup lifecycle policy: Short retention for frequent backups (e.g., 7 days daily), longer retention for weekly (30 days), and potentially permanent retention for monthly compliance backups.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide covered implementing a complete backup strategy for Longhorn using AWS S3:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Understanding HA, snapshots, and backups as complementary data protection layers</p>
</li>
<li>
<p>Configuring S3 buckets and IAM policies for secure off-cluster backup storage</p>
</li>
<li>
<p>Creating manual and automated backups with retention policies</p>
</li>
<li>
<p>Restoring from snapshots (fast, in-cluster) and backups (disaster recovery)</p>
</li>
<li>
<p>Managing backup lifecycle and deletion</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><br></p>
</div>
<div class="paragraph">
<p><strong>Key Takeaway</strong>: Production environments need all three layers—HA prevents downtime, snapshots enable quick recovery, and backups protect against catastrophic failures.</p>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
<div class="paragraph">
<p><strong>Next Steps</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Test restore procedures regularly in non-production environments</p>
</li>
<li>
<p>Set up automated backup schedules with appropriate retention</p>
</li>
<li>
<p>Configure monitoring and alerting for backup failures</p>
</li>
<li>
<p>Consider IRSA for production instead of static access keys</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://longhorn.io/docs/latest/snapshots-and-backups/">Longhorn Snapshots and Backups</a></p>
</li>
<li>
<p><a href="https://longhorn.io/docs/latest/backup-and-restore/">Backup and Restore</a></p>
</li>
<li>
<p><a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html">S3 Security Best Practices</a></p>
</li>
<li>
<p><a href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html">EKS IRSA Documentation</a></p>
</li>
</ul>
</div>
</div>
</div>
</body>
</html>