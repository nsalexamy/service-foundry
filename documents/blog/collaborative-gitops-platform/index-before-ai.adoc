= Collaborative GitOps Platform for Kubernetes Workload Management

:imagesdir: ./images

[.img-wide]
image::collaborative-gitops-platform.png[]

== Introduction

This project aims to build a collaborative GitOps platform for managing Kubernetes workloads. The platform leverages various tools and technologies to provide a seamless experience for developers and operators.

Service Foundry is a Kubernetes-based platform that simplifies the deployment and management of applications. It provides a set of tools and services to help developers and operators manage their applications effectively.

It supports the following features:

* Manage all Kubernetes resources in a Git repository.
* Automate the deployment of applications using ArgoCD.
* Provision custom enterprise applications saved in a private Container Registry.
* Provision Open Source applications saved in a public Container Registry.
* Built-in Oauth2 SSO authentication and authorization.
* Observability stack with Prometheus, Grafana, Loki, and Tempo etc.
* Applications orchestration for complex workloads like Observability stack and Big Data stack.
* Single Sign-On (SSO) integration for custom Kubernetes services.
* Encrypted secrets management using SealedSecrets.


This platform is designed to facilitate collaboration among team members, enabling them to work together on Kubernetes workloads using GitOps principles. By using Git as the single source of truth, the platform ensures that all changes to the infrastructure and applications are versioned and auditable.

=== Key Components

[.img-wide]
image::key-components.png[]

The key components of the platform include:

* Git Repository: A central repository to store Kubernetes manifests and configurations.
* ArgoCD: A declarative, GitOps continuous delivery tool for Kubernetes.
* Resource Generator: A tool to generate Kubernetes manifests from templates.
* Service Foundry Builder: A Kubernetes Job that executes the resource generator and pushes the generated manifests to the Git repository and creates ArgoCD applications.
* Service Foundry Console: A web-based interface for managing and monitoring the platform.
* Service Foundry Backend: A backend service that handles API requests and interacts with the Git repository and ArgoCD.


== Service Foundry Console

[.img-wide]
image::service-foundry-console.png[]
The Service Foundry Console is a web-based interface that allows users to manage and monitor the platform. It provides features such as:

=== Git Ops Menu

* *Managed Applications*: View and manage all applications deployed on the platform.
* *Enterprise Applications*: Provision custom enterprise applications from a private Container Registry. Kubernetes manifests are saved in a private Git repository and deployed using ArgoCD.
* *OpenSource Software*: Provision open-source applications from a public Container Registry. Kubernetes manifests are saved in a private Git repository and deployed using ArgoCD.
* *GitOps Applications*: View and manage all GitOps applications deployed on the platform. These applications can be deployed using ArgoCD or edited directly in the Git repository.

=== K8s Application Orchestration Menu

* *Framework Core*: Manage the core components of the platform, including ArgoCD, SealedSecrets, Keycloak, Traefik, Service Foundry Console, and Service Foundry Backend.
* *Shared Components*: Manage shared components such as cert-manager, prometheus-operator, opentelemetry-operator, and spark-operator. These components are supposed to be installed only once in the cluster.
* *Observability Stack*: Deploy and manage the observability stack, including OpenTelemetry Collector, Prometheus, Grafana, Loki, and Tempo and more. The observability stack is deployed using a predefined orchestration that sets up all necessary components and configurations. Kubernetes workloads and microservices can leverage the Observability stack for monitoring and tracing.
* *Single Sign-On (SSO) Stack*: Deploy and manage the SSO stack using Keycloak, Oauth2 Proxy, and Traefik Ingresses. The SSO stack is deployed using a predefined orchestration that sets up all necessary components and configurations. Custom enterprise applications can be integrated with the SSO stack for authentication and authorization.
* *Spring Backend*: Deploy and manage the Spring Backend stack, including Spring Boot applications, Spring ConfigWatcher, PostgreSQL, Redis, RabbitMQ, and other related components. Spring Boot microservices can leverage the Observability stack for monitoring and tracing and the SSO stack for authentication and authorization. The Spring Backend stack is deployed using a predefined orchestration that sets up all necessary components and configurations. (WIP)
* *Big Data*: Deploy and manage the big data stack, including Apache Airflow, Apache Spark, MinIO, Neo4j, OpenSearch stack, Dbt, Sling and ETL tools and databases. The big data stack is deployed using a predefined orchestration that sets up all necessary components and configurations. (WIP)

== GitOps - Manage Kubernetes Resources in Git

GitOps is a set of principles and practices for managing infrastructure and applications using Git as the single source of truth. In a GitOps workflow, all changes to the infrastructure and applications are made through pull requests to a Git repository. The changes are then automatically applied to the target environment using automation tools like ArgoCD.

=== ArgoCD - Continuous Delivery for Kubernetes

ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It continuously monitors the Git repository for changes and automatically applies them to the target environment. ArgoCD provides a web-based interface for managing and monitoring the deployment process.

==== Application types of ArgoCD

There are two types of applications in ArgoCD:

* *Kustomize Application*: A Kustomize application is a type of ArgoCD application that uses Kustomize to manage Kubernetes manifests. Kustomize allows users to create and manage Kubernetes resources using a declarative approach. Users can define a base set of resources and then create overlays to customize the resources for different environments.
* *Helm Application*: A Helm application is a type of ArgoCD application that uses Helm to manage Kubernetes manifests. Helm is a package manager for Kubernetes that allows users to define, install, and upgrade applications using charts. Users can create and manage Helm charts to package their applications and deploy them to Kubernetes clusters.

Service Foundry Builder supports both Kustomize and Helm applications. Users can choose the application type based on their requirements and preferences.

=== GitOps - Manage Applications Running on Kubernetes

[.img-wide]
image::managed-applications.png[]

The platform allows users to manage applications running on Kubernetes using GitOps principles. Users can view and manage all applications deployed on the platform, including custom enterprise applications and open-source software.

Argo CD statuses can be viewed directly in the Service Foundry Console. Argo CD applications can be uninstalled on this page if needed. Users can also edit the Kubernetes manifests directly in the Git repository using the built-in editor. Then the changes will be automatically applied to the cluster by Argo CD.

=== GitOps - Manage Custom Enterprise Applications

[.img-wide]
image::enterprise-applications.png[]

The platform provides a way to manage custom enterprise applications. Users can provision custom applications from a private Container Registry. Kubernetes manifests are saved in a private Git repository and deployed using ArgoCD.
The Secret manifests are encrypted using SealedSecrets to ensure the security of sensitive information.

==== Encrypting Secrets with SealedSecrets

[.img-wide]
image::encrypted-secrets.png[]

For Kubernetes Secrets, the platform uses SealedSecrets to encrypt sensitive information. SealedSecrets are encrypted using a public key, and only the controller running in the cluster can decrypt them using the corresponding private key. This ensures that sensitive information is not exposed in the Git repository.

=== GitOps - Manage Open Source Software

[.img-wide]
image::opensource-software.png[]
The platform also provides a way to manage open-source software. Users can provision open-source applications from a public Container Registry. Kubernetes manifests are saved in a private Git repository and deployed using ArgoCD.

=== GitOps - Manage GitOps Applications

[.img-wide]
image::gitops-applications.png[]
The platform allows users to manage all GitOps applications saved in the Git repository. These applications can be deployed using ArgoCD or edited directly in the Git repository. Uses can also delete the application manifests files and related Kubernetes manifests directly on this page if applications are no longer needed.

== Kubernetes Application Orchestration

Kubernetes application orchestration is a way to manage complex applications that consist of multiple components and services. The platform provides predefined orchestrations for various application stacks, including the Observability stack, SSO stack, Spring Backend stack, and Big Data stack.

=== Framework Core

The components in the Framework Core are the core components of the platform. They include ArgoCD, SealedSecrets, Keycloak, Traefik, Service Foundry Console, and Service Foundry Backend. These components are essential for the platform to function correctly. These components are deployed when the platform is set up for the first time.

[.img-wide]
image::framework-core.png[]

=== Shared Components

Shared components are the components that are used by multiple application stacks. They include cert-manager, prometheus-operator, opentelemetry-operator, and spark-operator. These components are supposed to be installed only once in the cluster and can be leveraged by other application stacks.

[.img-wide]
image::shared-components.png[]

=== Observability Stack

The Observability stack provides monitoring and tracing capabilities for Kubernetes workloads and microservices. It includes OpenTelemetry Collector, Prometheus, Grafana, Loki, and Tempo and more. The Observability stack is deployed using a predefined orchestration that sets up all necessary components and configurations. Kubernetes workloads and microservices can leverage the Observability stack for monitoring and tracing.

[.img-wide]
image::observability.png[]

==== Profiles

The Observability stack provides three profiles: Dev, Staging, adn Production. Each profile has different configurations and resource requirements.

Dev profile is designed for development and testing purposes. It has minimal resource requirements and is suitable for small-scale deployments.

* Prometheus
* Grafana
* OpenTelemetry Collector
* Kubelet Cadvisor Collector
* Tompo using MinIO as storage
* Loki using MinIO as storage
* MinIO

Staging profile is designed for staging and pre-production environments. It has moderate resource requirements and is suitable for medium-scale deployments.

* Prometheus
* Grafana
* OpenSearch
* OpenSearch Data Prepper
* OpenTelemetry Collector
* Kubelet Cadvisor Collector
* Tempo using S3 as storage
* Loki using S3 as storage
* MinIO

Production profile is designed for production environments. It has high resource requirements and is suitable for large-scale deployments.

* Cassandra
* Jaeger
* Prometheus
* Grafana
* OpenSearch
* OpenSearch Data Prepper
* OpenSearch Dashboards
* OpenTelemetry Collector
* Kubelet Cadvisor Collector
* Tempo using S3 as storage
* Loki using S3 as storage
* MinIO

=== Single Sign-On (SSO) Stack

The SSO stack provides authentication and authorization capabilities for custom Kubernetes services. It includes Keycloak, Oauth2 Proxy, and Traefik Ingresses. The SSO stack is deployed using a predefined orchestration that sets up all necessary components and configurations. Custom enterprise applications can be integrated with the SSO stack for authentication and authorization.

[.img-wide]
image::single-sign-on.png[]

All hostnames configured as the Ingress hosts in the SSO stack will be automatically added to the Keycloak's valid redirect URIs. And users can access these hostnames with the same SSO authentication session of Service Foundry Console.

== Conclusion

This collaborative GitOps platform provides a comprehensive solution for managing Kubernetes workloads using GitOps principles. By leveraging tools like ArgoCD, SealedSecrets, and predefined orchestrations, the platform simplifies the deployment and management of applications on Kubernetes. The web-based Service Foundry Console offers an intuitive interface for users to manage and monitor their applications effectively.

The platform is designed to facilitate collaboration among team members, enabling them to work together on Kubernetes workloads using Git as the single source of truth. This ensures that all changes to the infrastructure and applications are versioned and auditable, promoting transparency and accountability within the team.
