= Presenter Scripts: Using Kustomize With Custom Helm Charts for ArgoCD
:toc:
:toclevels: 2

---

== YouTube Publishing Metadata

=== YouTube Title

**Option 1 (Concise):**
----
Deploy Multi-Environment Apps with Kustomize, Helm & ArgoCD | GitOps Tutorial
----

**Option 2 (Descriptive):**
----
How to Deploy Apps to Dev, Staging & Prod using Kustomize + Helm + ArgoCD
----

**Option 3 (Problem-Focused):**
----
Multi-Environment Kubernetes Deployments: Kustomize + Helm + ArgoCD Complete Guide
----

=== YouTube Description

----
Learn how to deploy the same Kubernetes application to multiple environments (dev, staging, prod) using Kustomize, Helm, and ArgoCD in this comprehensive GitOps tutorial.

üéØ What You'll Learn:
‚Ä¢ Pull and use custom Helm charts from private AWS ECR registry
‚Ä¢ Create environment-specific configurations with Kustomize overlays
‚Ä¢ Manage secrets securely with Bitnami SealedSecrets
‚Ä¢ Set up ArgoCD Applications for automated GitOps deployments
‚Ä¢ Use ArgoCD ApplicationSets to manage multiple environments efficiently

‚è±Ô∏è Timestamps:
0:00 - Introduction
1:00 - What We're Building
3:00 - Prerequisites
3:30 - GitOps Repository Structure
5:30 - The ECR Challenge and Solution
7:30 - The Sealed Secrets Challenge
10:30 - Configuring the Dev Environment
13:30 - ArgoCD Applications - Two Approaches
16:30 - Deploying Everything
18:30 - Conclusion and Next Steps

üîó Resources:
üìù Written Guide: https://nsalexamy.github.io/service-foundry/pages/documents/blog/kustomize-custom-helm-chart/
üíª GitHub Repo: [Add your repo URL]
üì∫ Previous Video - Creating Custom Helm Charts: https://youtu.be/mGtIVDMaUkg

üìö Documentation Links:
‚Ä¢ Kustomize: https://kustomize.io/
‚Ä¢ ArgoCD: https://argo-cd.readthedocs.io/
‚Ä¢ Sealed Secrets: https://github.com/bitnami-labs/sealed-secrets
‚Ä¢ Helm: https://helm.sh/

üéì What This Tutorial Covers:
This hands-on tutorial walks through a real-world multi-environment deployment scenario. You'll learn how to overcome the limitation of Kustomize not being able to access private OCI registries, understand why SealedSecrets are namespace-scoped, and implement a complete GitOps workflow using ArgoCD.

We'll deploy the Service Foundry Community application (a full-stack app with Go backend and React frontend) to three completely isolated environments with different configurations, sealed secrets, and hostnames.

üí° Key Takeaways:
‚úì Kustomize cannot access private OCI registries - use local charts
‚úì SealedSecrets are namespace-scoped - create separate secrets per environment
‚úì ApplicationSets reduce duplication across similar environments
‚úì GitOps ensures your cluster state always matches your Git repository

üè∑Ô∏è Topics Covered:
#Kubernetes #ArgoCD #Kustomize #Helm #GitOps #DevOps #CloudNative #CNCF #SealedSecrets #MultiEnvironment #CI/CD #InfrastructureAsCode

üë®‚Äçüíª About Service Foundry:
Service Foundry provides open-source tools and educational content for building cloud-native applications with Kubernetes.

üîî Subscribe for more Kubernetes, DevOps, and Cloud Native tutorials!

---

üí¨ Questions? Drop them in the comments below!
üëç If this helped you, please like and share!

#GitOps #KubernetesTutorial #ArgoCD #DevOps2024
----

=== YouTube Tags

----
Kustomize
ArgoCD
Helm
Kubernetes
GitOps
DevOps
Multi-environment deployment
Kubernetes tutorial
ArgoCD tutorial
Kustomize tutorial
Helm charts
SealedSecrets
Bitnami SealedSecrets
AWS ECR
Kubernetes secrets management
ApplicationSet
ArgoCD ApplicationSet
Cloud native
CNCF
Infrastructure as Code
IaC
Continuous deployment
CD pipeline
Kubernetes deployment
Dev staging prod
Environment management
Microservices
Container orchestration
Kubernetes best practices
GitOps workflow
Declarative deployment
Kubernetes automation
ArgoCD GitOps
Helm OCI
Traefik ingress
Kubernetes ingress
Multi-tenant Kubernetes
Namespace isolation
Kubernetes overlays
Kustomize overlays
Helm values
ConfigMap
Kubernetes ConfigMap
Service Foundry
Go backend
React frontend
Full-stack Kubernetes
----

---

== LinkedIn Publishing Metadata

=== LinkedIn Post Summary

**Option 1 (Professional & Concise):**
----
üöÄ New Tutorial: Multi-Environment Kubernetes Deployments with GitOps

I just published a comprehensive guide on deploying applications to dev, staging, and production environments using Kustomize, Helm, and ArgoCD.

Key highlights:
‚úÖ Pull private Helm charts from AWS ECR for local use with Kustomize
‚úÖ Manage environment-specific configurations with Kustomize overlays
‚úÖ Secure secrets management with namespace-scoped SealedSecrets
‚úÖ Automated GitOps deployments with ArgoCD ApplicationSets

This tutorial solves real-world challenges like Kustomize's inability to access private OCI registries and explains why you need separate SealedSecrets per namespace.

Perfect for DevOps engineers, platform engineers, and anyone working with Kubernetes in production.

üé• Watch the full tutorial: [YouTube URL]
üìù Written guide: https://nsalexamy.github.io/service-foundry/pages/documents/blog/kustomize-custom-helm-chart/

#Kubernetes #DevOps #GitOps #ArgoCD #CloudNative #SRE
----

**Option 2 (Story-Driven):**
----
üí° Ever struggled with deploying the same app to multiple Kubernetes environments?

I've been there. Managing separate configurations for dev, staging, and prod while keeping secrets secure and deployments automated is challenging.

In my latest tutorial, I walk through a complete GitOps workflow using:
‚Ä¢ Kustomize for environment-specific overlays
‚Ä¢ Helm for templating  
‚Ä¢ ArgoCD for automated deployments
‚Ä¢ SealedSecrets for secure secret management

One of the trickiest parts? Kustomize can't access private OCI registries like AWS ECR. I show you exactly how to work around this limitation.

Another gotcha? SealedSecrets are namespace-scoped by design. I explain why this matters and how to properly structure your secrets.

By the end, you'll have three completely isolated environments, all managed from a single Git repository with full automation.

üéØ Who is this for?
Platform engineers, DevOps teams, and anyone running Kubernetes in production.

üîó Full tutorial and code: [links in comments]

What's your biggest challenge with multi-environment Kubernetes deployments? Share in the comments! üëá

#Kubernetes #DevOps #GitOps #ArgoCD #PlatformEngineering #CloudNative #CNCF
----

**Option 3 (Quick & Technical):**
----
üìΩÔ∏è New Deep Dive: Kustomize + Helm + ArgoCD for Multi-Environment Deployments

Just dropped a technical tutorial covering a complete GitOps setup for deploying to dev/staging/prod Kubernetes environments.

üîß Technical stack:
- Kustomize for environment overlays
- Helm for application packaging
- ArgoCD for GitOps automation
- SealedSecrets for secret encryption
- AWS ECR for chart storage
- Traefik for ingress routing

üéì You'll learn:
‚Ä¢ How to use private Helm charts with Kustomize (workaround for OCI registry limitation)
‚Ä¢ Proper SealedSecret namespace scoping
‚Ä¢ ArgoCD ApplicationSets for DRY multi-env management
‚Ä¢ Complete GitOps workflow from code to cluster

Real-world example using a full-stack application (Go backend + React frontend) deployed across three isolated namespaces.

Link in comments üëá

#GitOps #Kubernetes #ArgoCD #DevOps #SRE #CloudEngineering
----

=== LinkedIn Tags/Hashtags

**Primary Tags (Use 3-5 in post):**
----
#Kubernetes
#DevOps
#GitOps
#ArgoCD
#CloudNative
----

**Secondary Tags (Include in comments or vary across posts):**
----
#SRE
#PlatformEngineering
#CloudEngineering
#InfrastructureAsCode
#CNCF
#ContainerOrchestration
#Microservices
#ContinuousDeployment
#DevSecOps
#Kustomize
#Helm
#KubernetesTutorial
#TechTutorial
#LearnToCode
#SoftwareEngineering
#CloudComputing
#AWS
#EKS
#DevOpsTutorial
#AutomationEngineering
----

**Industry/Company Tags:**
----
#TechEducation
#DeveloperTools
#OpenSource
#CloudTechnology
#EnterpriseIT
#DigitalTransformation
----

=== LinkedIn Article Title (if publishing as article)

----
Deploy Kubernetes Apps to Multiple Environments with Kustomize, Helm, and ArgoCD: A Complete GitOps Guide
----

=== LinkedIn Article Summary (if publishing as article)

----
Learn how to build a production-ready multi-environment deployment system for Kubernetes using Kustomize, Helm, and ArgoCD. This comprehensive guide covers environment-specific configurations, secure secret management with SealedSecrets, and automated GitOps workflows. Perfect for DevOps engineers and platform teams managing development, staging, and production environments.
----

---

== Video Structure

This script is divided into segments for easy recording and editing.
Each segment includes:

* *[PAUSE]* - Natural pause for breath or emphasis
* *[SHOW: ...]* - Visual cue for screen recording or graphics
* *[TRANSITION]* - Scene change or visual transition

Estimated total video length: 15-20 minutes

---

== SEGMENT 1: Introduction (1 minute)

[SHOW: Title screen with channel logo]

Hey everyone, welcome back to the channel!

[PAUSE]

Today, we're tackling a really practical challenge that comes up in Kubernetes deployments all the time. [PAUSE] How do you deploy the same application to multiple environments... like development, staging, and production... using different configurations for each?

[PAUSE]

[SHOW: Split screen showing dev, staging, prod environments]

We'll be combining three powerful tools: Kustomize, Helm, and ArgoCD. [PAUSE] By the end of this tutorial, you'll have a complete GitOps workflow that automatically deploys your applications across all your environments.

[PAUSE]

[SHOW: Quick preview of final ArgoCD UI with all three environments]

Let's dive in!

[TRANSITION]

---

== SEGMENT 2: What We're Building (2 minutes)

[SHOW: Architecture diagram]

So, what exactly are we building today?

[PAUSE]

We'll be deploying the Service Foundry Community application. [PAUSE] This is a Helm chart I created in a previous video, and it contains two subcharts: a Go-based backend API and a React frontend application.

[PAUSE]

[SHOW: Helm chart structure tree]

The interesting part is how we handle routing. [PAUSE] We're using Traefik's Ingress Route to direct traffic. Requests to slash API go to the backend, and everything else goes to the frontend. Pretty standard microservices pattern.

[PAUSE]

[SHOW: IngressRoute YAML highlighted]

Now, this chart is stored in AWS E-C-R... that's Amazon's container registry... as an OCI artifact. [PAUSE] We'll pull it down and use it with Kustomize.

[PAUSE]

[SHOW: Final result - three URLs]

By the end, we'll have three live environments:
- Development at community dash dev dot service foundry dot org
- Staging at community dash staging dot service foundry dot org  
- And production at community dot service foundry dot org

[PAUSE]

Each environment will have its own configuration, its own secrets, and be completely isolated.

[TRANSITION]

---

== SEGMENT 3: Prerequisites Quick Check (30 seconds)

[SHOW: Checklist graphic]

Before we start, make sure you have:

First, a Kubernetes cluster with ArgoCD installed. [PAUSE]

Second, the AWS CLI configured with access to E-C-R. [PAUSE]

Third, the Helm CLI installed. [PAUSE]

And finally, a basic understanding of Kubernetes, Helm, and Kustomize concepts.

[PAUSE]

If you need help with any of these, I'll link to setup guides in the description below.

[TRANSITION]

---

== SEGMENT 4: Understanding the GitOps Repository Structure (2 minutes)

[SHOW: File explorer showing directory structure]

Let's look at how we organize our GitOps repository.

[PAUSE]

At the top level, we have six directories. Let me walk you through each one.

[PAUSE]

[SHOW: Highlight each directory as mentioned]

First, the *argocd* folder. [PAUSE] This contains our ArgoCD Application manifests... basically, the configurations that tell ArgoCD what to deploy and where.

[PAUSE]

Second, the *base* folder. [PAUSE] In this example, it's actually empty, but you'd typically use this for shared resources across all environments. We'll see why we're not using it in a moment.

[PAUSE]

Third, *chart dash home*. [PAUSE] This is where our extracted Helm chart lives. All environments will reference this same chart.

[PAUSE]

Then we have three environment folders: *dev*, *staging*, and *prod*. [PAUSE] Each contains environment-specific configurations... like hostnames, image versions, and secrets.

[PAUSE]

[SHOW: Table showing environment-specific values]

This structure follows a common Kustomize pattern. [PAUSE] You have a base... though we're not using it here... and overlays for each environment.

[TRANSITION]

---

== SEGMENT 5: The ECR Challenge and Solution (2 minutes)

[SHOW: Diagram showing Kustomize trying to access ECR with an X]

Now, here's an important limitation you need to know about.

[PAUSE]

Kustomize, when running inside ArgoCD, cannot directly access private OCI registries like AWS E-C-R. [PAUSE] This is a security and authentication limitation.

[PAUSE]

So how do we solve this?

[PAUSE]

[SHOW: Solution diagram - pull chart locally to Git]

We pull the chart once and commit it to our Git repository. [PAUSE] This approach has several benefits:

[PAUSE]

First, it works seamlessly with ArgoCD and Kustomize. [PAUSE]
Second, it ensures all environments use the exact same chart version. [PAUSE]
Third, it follows GitOps principles... everything is in Git. [PAUSE]
And fourth, ArgoCD doesn't need to authenticate with E-C-R at all.

[PAUSE]

[SHOW: Terminal with commands]

Let me show you the commands.

[PAUSE]

First, we authenticate with E-C-R using the AWS CLI and Helm registry login:

[READ SLOWLY]
aws ecr get-login-password, pipe to helm registry login with the username AWS.

[PAUSE]

Then we pull and extract the chart:

[PAUSE]

We use helm pull with the O-C-I protocol, specify our E-C-R URL, and most importantly, use the dash dash untar flag.

[PAUSE]

[SHOW: Highlight --untar flag]

The untar flag is crucial. [PAUSE] Kustomize can't work with tgz archives... it needs the extracted directory structure.

[TRANSITION]

---

== SEGMENT 6: The Sealed Secrets Challenge (3 minutes)

[SHOW: Sealed Secret logo or icon]

Alright, let's talk about secrets management. [PAUSE] This is where things get interesting.

[PAUSE]

You might think: "Why not create one sealed secret in the base folder and patch it for each environment?" [PAUSE] That sounds reasonable, right?

[PAUSE]

[SHOW: Code showing base/kustomization.yaml with a sealed secret]

Well, that approach doesn't work. [PAUSE] And understanding why is really important.

[PAUSE]

[SHOW: Diagram explaining SealedSecret scope]

Sealed Secrets, by default, use what's called "strict scope." [PAUSE] This means the encryption is bound to two things: the secret name AND the target namespace.

[PAUSE]

This is actually a security feature. [PAUSE] It prevents secrets from being accidentally... or maliciously... moved between namespaces.

[PAUSE]

[SHOW: Sealed Secret encrypted for 'dev' with an X over 'staging' and 'prod']

So a Sealed Secret encrypted for the dev namespace literally cannot be decrypted in staging or prod. [PAUSE] The sealed-secrets controller will reject it.

[PAUSE]

[SHOW: Solution - three separate sealed secrets]

The solution? [PAUSE] Create three separate sealed secrets, one for each environment.

[PAUSE]

Each secret is encrypted with its target namespace:
- service dash foundry dash license dash keys dash dev for the dev namespace
- service dash foundry dash license dash keys dash staging for staging
- And service dash foundry dash license dash keys dash prod for production

[PAUSE]

Yes, this means a bit of duplication, but it's the secure way to do it. [PAUSE] And honestly, in practice, you'd typically have different secrets per environment anyway.

[TRANSITION]

---

== SEGMENT 7: Configuring the Dev Environment (3 minutes)

[SHOW: dev/ directory structure]

Now let's dive into an actual environment configuration. [PAUSE] We'll use dev as our example, but staging and prod follow the exact same pattern.

[PAUSE]

Each environment folder contains three files:

[SHOW: Highlight each file]

First, kustomization dot yaml... the Kustomize configuration. [PAUSE]
Second, the environment-specific sealed secret. [PAUSE]
And third, the values file for Helm.

[PAUSE]

[SHOW: dev/kustomization.yaml file]

Let's look at the kustomization file.

[PAUSE]

At the top, we set the namespace to dev. [PAUSE] This means all resources will be deployed to the dev namespace.

[PAUSE]

Under resources, we include our dev-specific sealed secret.

[PAUSE]

[SHOW: Highlight helmGlobals section]

Then comes the helmGlobals section. [PAUSE] This tells Kustomize where to find our Helm chart. We point it to dot dot slash chart dash home.

[PAUSE]

[SHOW: Highlight helmCharts section]

And finally, the helm-Charts section. [PAUSE] This is where we configure which chart to render and which values file to use.

[PAUSE]

We specify the chart name, the release name, the namespace, and point to our values dash dev dot yaml file.

[PAUSE]

[SHOW: dev/values-dev.yaml file]

Speaking of values... let's look at that file.

[PAUSE]

[SHOW: Highlight each section]

First, we set the global version. [PAUSE] This controls which version of our backend and frontend images get deployed. In this case, version zero point two point zero.

[PAUSE]

Next, the host. [PAUSE] This is the hostname for this environment... community dash dev dot service-foundry dot org. This value gets used in our Ingress Route.

[PAUSE]

And finally, frontend configuration. [PAUSE] This is the runtime config for our React app. It includes the backend API endpoint, the app version, and the builder version.

[PAUSE]

Notice how the backend server URL matches our host with slash API. [PAUSE] This is how the frontend knows where to send API requests.

[PAUSE]

For staging and prod, we'd have values dash staging and values dash prod files with different hostnames, possibly different versions, and maybe other environment-specific settings.

[TRANSITION]

---

== SEGMENT 8: ArgoCD Applications - Two Approaches (3 minutes)

[SHOW: ArgoCD logo]

Now we need to tell ArgoCD about our applications. [PAUSE] And there are two ways to do this.

[PAUSE]

[SHOW: Four files in argocd/ directory]

Approach one: individual Application manifests. [PAUSE] You create a separate file for dev, staging, and prod. This gives you fine-grained control over each environment.

[PAUSE]

Approach two: an Application-Set. [PAUSE] This lets you manage all three environments with a single manifest. Very D-R-Y... Don't Repeat Yourself.

[PAUSE]

Let me show you both.

[PAUSE]

[SHOW: service-foundry-community-dev-application.yaml]

Here's the dev Application manifest.

[PAUSE]

[SHOW: Highlight metadata section]

We give it a name and add a finalizer. [PAUSE] The finalizer ensures ArgoCD cleans up resources when the Application is deleted.

[PAUSE]

[SHOW: Highlight source section]

In the source section, we specify our Git repository URL, the branch... main in this case... and the path to our dev overlay.

[PAUSE]

[SHOW: Highlight destination section]

The destination tells ArgoCD which cluster and namespace to deploy to. [PAUSE] The default server means "the cluster where ArgoCD is running."

[PAUSE]

[SHOW: Highlight syncPolicy section]

And the sync-Policy is really important. [PAUSE] We enable automated syncing, which means ArgoCD will automatically deploy when it detects changes in Git.

[PAUSE]

Prune true means it'll delete resources that are removed from Git. [PAUSE]
Self-Heal true means it'll revert any manual changes back to the Git state. [PAUSE]
This is GitOps in action!

[PAUSE]

[SHOW: ApplicationSet file]

Now, the Application-Set approach.

[PAUSE]

[SHOW: Highlight generators.list section]

Instead of three separate files, we define a list generator. [PAUSE] This is just an array with environment names and namespaces.

[PAUSE]

[SHOW: Highlight template section]

Then we have a template. [PAUSE] ArgoCD will render this template once for each item in our list.

[PAUSE]

[SHOW: Highlight template variables]

See these double curly braces? [PAUSE] Those are template variables. They get replaced with env and namespace from our list.

[PAUSE]

[SHOW: Final result visualization]

So this one Application-Set manifest creates three Applications automatically:
- service dash foundry dash community dash dev
- service dash foundry dash community dash staging  
- And service dash foundry dash community dash prod

[PAUSE]

Pretty cool, right? [PAUSE] Application-Sets are great when you have many similar environments.

[TRANSITION]

---

== SEGMENT 9: Deploying Everything (2 minutes)

[SHOW: Terminal ready for commands]

Alright, moment of truth! [PAUSE] Let's deploy.

[PAUSE]

We have two options, just like with the manifests.

[PAUSE]

[SHOW: kubectl apply command for dev]

Option one: deploy just the dev environment first to test:

kubectl apply dash f argocd slash service dash foundry dash community dash dev dash application dot yaml

[PAUSE]

[SHOW: ArgoCD UI loading]

ArgoCD will now:
- Clone your Git repository
- Run Kustomize to render the dev overlay
- Execute Helm template rendering
- Create the sealed secret
- And deploy all resources to the dev namespace

[PAUSE]

[SHOW: ArgoCD UI with synced application]

After a few moments, you can view the application in the ArgoCD UI. [PAUSE] You'll see the sync status, health status, and the complete resource tree.

[PAUSE]

[SHOW: Browser opening community-dev.servicefoundry.org]

And once everything is healthy, you can access the application at community dash dev dot service-foundry dot org.

[PAUSE]

[SHOW: Service Foundry Community dev site]

There it is! [PAUSE] Our development environment running.

[PAUSE]

[SHOW: Terminal with ApplicationSet command]

Option two: deploy all three environments at once using the Application-Set:

kubectl apply dash f argocd slash service dash foundry dash community dash application-set dot yaml

[PAUSE]

[SHOW: ArgoCD UI with three applications]

Now you'll see all three applications in ArgoCD. [PAUSE] Each one is syncing and deploying to its respective namespace.

[PAUSE]

[SHOW: Browser tabs with all three URLs]

And we can access all three:
- Development
- Staging  
- And production

[PAUSE]

[SHOW: Production site]

Here's production running at community dot service-foundry dot org.

[PAUSE]

Each environment is completely isolated with its own namespace, secrets, Helm values, and resources.

[TRANSITION]

---

== SEGMENT 10: Conclusion and Next Steps (1.5 minutes)

[SHOW: Recap graphic]

Let's recap what we've accomplished today.

[PAUSE]

We pulled a custom Helm chart from AWS E-C-R and made it usable with Kustomize by extracting it locally.

[PAUSE]

We created environment-specific overlays with different hostnames, versions, and configurations.

[PAUSE]

We managed secrets securely using Sealed-Secrets with proper namespace scoping.

[PAUSE]

We set up ArgoCD Applications to automatically deploy and sync from Git.

[PAUSE]

And we used ArgoCD Application-Sets to manage multiple environments with a single manifest.

[PAUSE]

[SHOW: Key takeaways list]

Here are the key takeaways:

One: Kustomize can't access private OCI registries. Pull charts locally and commit them to Git.

[PAUSE]

Two: Sealed-Secrets are namespace-scoped. Create separate secrets for each namespace.

[PAUSE]

Three: Application-Sets reduce duplication and are great for managing similar applications across environments.

[PAUSE]

Four: This is GitOps in action. All configuration is versioned in Git, and ArgoCD ensures your cluster matches the desired state.

[PAUSE]

[SHOW: Next steps list]

Here are some ways you can extend this setup:

Add more environments like Q-A or staging two. [PAUSE]
Implement promotion workflows using Git tags or branches. [PAUSE]
Add Helm hooks for database migrations. [PAUSE]
Configure ArgoCD notifications for Slack or email. [PAUSE]
Or implement progressive rollouts using ArgoCD's sync waves.

[PAUSE]

[SHOW: Resources and links]

I've linked all the resources in the description below, including the GitHub repo with all the code, the Kustomize docs, the ArgoCD docs, and the Sealed Secrets documentation.

[PAUSE]

[SHOW: End screen with subscribe button]

If you found this helpful, please give it a thumbs up and subscribe for more Kubernetes and DevOps tutorials.

[PAUSE]

Drop a comment below if you have any questions or if there's a topic you'd like me to cover next.

[PAUSE]

Thanks for watching, and I'll see you in the next video!

[END]

---

== Production Notes

=== Pacing Guidelines

* Speak at a moderate pace (approximately 150-160 words per minute)
* Pause at [PAUSE] markers for 0.5-1 second
* Take a 2-3 second pause at [TRANSITION] markers
* Technical terms (ECR, OCI, YAML) should be pronounced clearly

=== Visual Requirements

* Have terminal ready with commands pre-typed for smooth demonstration
* ArgoCD UI should be accessible in a browser
* Have both individual Application files and ApplicationSet file ready to show
* Prepare architecture diagrams for:
  - Overall system architecture
  - Kustomize + ECR limitation explanation
  - SealedSecret scope explanation
  - ApplicationSet template rendering

=== B-Roll Suggestions

* Kubernetes cluster dashboard
* Git repository commits
* ArgoCD sync animations
* Application health checks transitioning from yellow to green

=== Editing Notes

* Add lower-third text labels for technical terms when first mentioned
* Consider split-screen for comparing dev/staging/prod configurations
* Use zoom-in effects when highlighting specific YAML sections
* Add gentle background music (low volume) during code walkthroughs
* Include chapter markers at each SEGMENT for YouTube's timeline feature

=== Chapter Timestamps (for YouTube description)

0:00 - Introduction
1:00 - What We're Building  
3:00 - Prerequisites
3:30 - GitOps Repository Structure
5:30 - The ECR Challenge and Solution
7:30 - The Sealed Secrets Challenge
10:30 - Configuring the Dev Environment
13:30 - ArgoCD Applications - Two Approaches
16:30 - Deploying Everything
18:30 - Conclusion and Next Steps
