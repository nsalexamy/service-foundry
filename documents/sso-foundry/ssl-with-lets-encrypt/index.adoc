= Enable TLS/SSL with Let's Encrypt

== Overview


== DNS Configuration

Type: A
Name: @
Value: WebsiteBuilder Site
TTL: 1 Hour

Value: <IP_ADDRESS_OF_YOUR_LOAD_BALANCER>

== ClusterIssuer

First, create a ClusterIssuer resource for the CA-based certificates.

.clusterissuer-letsencrypt-http.yaml
[source,yaml]
----
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-http
  namespace: cert-manager
spec:
  acme:
    # Your contact email (used for renewal notices)
    email: credemol@gmail.com

    # Letâ€™s Encrypt production server
    # For testing, use: https://acme-staging-v02.api.letsencrypt.org/directory
    server: https://acme-v02.api.letsencrypt.org/directory

    # Secret where the ACME account private key is stored
    privateKeySecretRef:
      name: letsencrypt-http-key

    # Use HTTP-01 challenge via Traefik ingress
    solvers:
      - http01:
          ingress:
            class: traefik
----

Apply the ClusterIssuer resource:
[source,shell]
----
$ kubectl apply -f clusterissuer-letsencrypt-http.yaml
----

It generates TLS private key in the secret `letsencrypt-http-private-key` in the `cert-manager` namespace.

== Create a Certificate resource

Next, create a Certificate resource to request a TLS certificate for your domain.

.certificate-servicefoundry.yaml
[source,yaml]
----
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: servicefoundry-ca-cert
  namespace: service-foundry
spec:
  secretName: servicefoundry-ca-tls
  issuerRef:
    name: letsencrypt-http
    kind: ClusterIssuer
  commonName: servicefoundry.ca
  dnsNames:
    - servicefoundry.ca
    #- '*.servicefoundry.ca'
    #- www.servicefoundry.ca
    - sfapp.servicefoundry.ca
    #- sfapp-backend.servicefoundry.ca
----

Apply the Certificate resource:
[source,shell]
----
$ kubectl apply -f certificate-servicefoundry.yaml
----

This creates a TLS certificate for `servicefoundry.ca` and `*.servicefoundry.ca`, stored in the secret `servicefoundry-tls` in the `cert-manager` namespace.

