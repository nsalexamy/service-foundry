= Self Signed Certificate for SSO Foundry

:imagesdir: images


== Overview


This article covers:

- Install cert-manager in your Kubernetes cluster
- Create a self-signed certificate using cert-manager
- Configure SSO Foundry to use the self-signed certificate

== Install cert-manager

TBD

== Create a self-signed bootstrap issuer

First, create a ClusterIssuer resource for the self-signed certificate.

.cert-manager/clusterissuer-selfsigned-bootstrap.yaml
[source,yaml]
----
# cert-manager/clusterissuer-selfsigned-bootstrap.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-bootstrap
  namespace: cert-manager
spec:
  selfSigned: {}
----

Apply the ClusterIssuer resource:
[source,shell]
----
$ kubectl apply -f cert-manager/clusterissuer-selfsigned-bootstrap.yaml
----

== Mint the root CA certificate

This certificate is isCA: true, and the secret (nsa2-root-ca) will store both the CA cert and private key.

.cert-manager/nsa2-root-ca.yaml
[source,yaml]
----
# cert-manager/nsa2-root-ca.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: nsa2-root-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: nsa2-root-ca
  secretName: nsa2-root-ca
  duration: 87600h   # 10 years
  privateKey:
    algorithm: RSA
    size: 2048
  issuerRef:
    name: selfsigned-bootstrap
    kind: ClusterIssuer
----

Apply and wait for the certificate to be ready:
[source,shell]
----
$ kubectl apply -f cert-manager/nsa2-root-ca.yaml

$ kubectl -n cert-manager wait --for=condition=Ready certificate/nsa2-root-ca --timeout=90s
----

== Create a CA-based ClusterIssuer (cluster-wide signer)

This ClusterIssuer references the root CA secret, so it can sign certificates for any namespace.

.cert-manager/clusterissuer-nsa2-ca.yaml
[source,yaml]
----
# cert-manager/clusterissuer-nsa2-ca.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: nsa2-ca
  namespace: cert-manager
spec:
  ca:
    secretName: nsa2-root-ca
----

Apply:

[source,shell]
----
$ kubectl apply -f cert-manager/clusterissuer-nsa2-ca.yaml
----

== Issue a wildcard certificate for your domain (*.nsa2.com)

Now that your global issuer exists, you can issue your wildcard certificate in any app namespace (e.g., default).

.service-foundry/wildcard-nsa2-com.yaml
[source,yaml]
----
# default/wildcard-nsa2-com.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-nsa2-com
  namespace: service-foundry
spec:
  secretName: wildcard-nsa2-com-tls   # Traefik will use this secret
  issuerRef:
    name: nsa2-ca
    kind: ClusterIssuer
  commonName: "*.nsa2.com"
  dnsNames:
    - "*.nsa2.com"
    - "nsa2.com"
  privateKey:
    algorithm: RSA
    size: 2048
  duration: 2160h      # 90 days
  renewBefore: 360h    # renew 15 days before expiry
----

Apply and wait for the certificate to be ready:
[source,shell]
----
$ kubectl apply -f service-foundry/wildcard-nsa2-com.yaml
$ kubectl -n service-foundry wait --for=condition=Ready certificate/wildcard-nsa2-com --timeout=90s
----

This will create a secret named wildcard-nsa2-com in the service-foundry namespace.

[source,shell]
----
% kubectl -n service-foundry get secret/wildcard-nsa2-com -o yaml
----

Output:
[source,yaml]
----
data:
  ca.crt: <base64-encoded-ca-certificate>
  tls.crt: <base64-encoded-certificate>
  tls.key: <base64-encoded-private-key>
----



== Configure IngressRoute to use the certificate

Finally, update your IngressRoute resources to reference the new wildcard certificate.

[source,yaml]
----

apiVersion: traefik.io/v1alpha1
kind: IngressRoute
metadata:
  name: service-foundry-sso-ingress-route
  namespace: service-foundry
spec:
  entryPoints:
    - web
  routes:


    - match: Host(`sfapp.nsa2.com`)
      kind: Rule
      services:
        - name: service-foundry-app-frontend
          port: http
      middlewares:
        - name: cors-headers
        - name: forward-auth


    - match: Host(`sfapp-backend.nsa2.com`)
      kind: Rule
      services:
        - name: service-foundry-app-backend
          port: http
      middlewares:
        - name: cors-headers
        - name: forward-auth
  # <1> Reference the TLS secret for the wildcard certificate
  tls:
    secretName: wildcard-nsa2-com-tls
----

.cors-headers-middleware.yaml
[source,yaml]
----

apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: cors-headers
  namespace: service-foundry # replace with actual namespace, e.g., traefik or default
spec:
  headers:
    accessControlAllowMethods:
      - "GET"
      - "OPTIONS"
      - "PUT"
      - "POST"
      - "DELETE"
      - "PATCH"
      - "HEAD"
    accessControlAllowHeaders:
      - Origin
      - Content-Type
      - Authorization
      - Accept
      - User-Agent
      - Cache-Control
      - X-Requested-With
      - Access-Control-Allow-Origin
      - Access-Control-Allow-Headers
      - traceparent
    accessControlAllowOriginList:
      # <1> Add your allowed origins here
      - "http://sfapp.nsa2.com"
      - "https://sfapp.nsa2.com"
      - "http://sfapp-backend.nsa2.com"
      - "https://sfapp-backend.nsa2.com"
    accessControlMaxAge: 100
    accessControlAllowCredentials: true
    addVaryHeader: true
----
<1> Add https and http origins as needed.