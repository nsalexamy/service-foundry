= Automating Route 53 DNS Updates When New ALBs Are Provisioned with Terraform

:imagesdir: tf-images

[.img-wide]
image::intro.png[]

== Introduction

In this guide, we will demonstrate how to automate the updating of Route 53 DNS records when a new AWS Application Load Balancer (ALB) is provisioned using Terraform. This automation ensures that your domain always points to the correct ALB without manual intervention.

This guide is the follow-up to https://youtu.be/EW4uJ6hUIRE[Securing Web Apps on Kubernetes with TLS Using AWS Load Balancer Controller and Traefik]

In the previous guide, we set up Route 53 DNS records to point to an ALB created by the AWS Load Balancer Controller. However, if the ALB is deleted and recreated (for example, during cluster upgrades or changes), the DNS records would need to be updated manually. This guide shows you how to automate that process using Terraform.

== Source Code Repository

The complete source code for this guide is available in the following GitHub repository:

https://github.com/nsalexamy/secure-web-app-on-k8s-with-tls

.GitHub Repository
[.img-wide]
image::github-repo.png[]

== apply-terraform shell script

The `apply-terraform.sh` script is designed to be run after the ALB Ingress resource has been deployed. It waits for the ALB to become active, retrieves the hosted zone ID from Route 53, and then applies the Terraform configuration to update the DNS records accordingly.

.apply-terraform.sh - wait for ALB active
[source,bash]
----
#!/bin/bash

CWD=$(pwd)
TERRAFORM_DIR=$CWD/terraform

wait_for_alb_active() {
  # use aws cli to wait for alb to be active
  local alb_name="$1"
  local timeout_seconds="${2:-600}"     # default: 600 seconds
  local interval_seconds="${3:-5}"      # default: 5 seconds
  local max_retries=$((timeout_seconds / interval_seconds))
  echo "Waiting for ALB $alb_name to become active..."
  for ((i=1; i<=max_retries; i++)); do
    alb_state=$(aws elbv2 describe-load-balancers --names "$alb_name" --query 'LoadBalancers[0].State.Code' --output text 2>/dev/null || true)
    if [[ "$alb_state" == "active" ]]; then
      echo "ALB $alb_name is active."
      return 0
    fi
    sleep "$interval_seconds"
  done

  echo "Timed out waiting for ALB $alb_name to become active." >&2
  return 1
}
----


The code snippet below shows how to call the `wait_for_alb_active` function within the `apply-terraform.sh` script.

.apply-terraform.sh - call wait_for_alb_active
[source,bash]
----
ALB_NAME="traefik-alb"

if ! wait_for_alb_active "$ALB_NAME"; then
  echo "Exiting due to timeout"
  exit 1
fi
----

In the code snippet below, first we retrieve the hosted zone ID for the specified DNS name from Route 53. Then we initialize Terraform and check if the DNS record already exists. If it does, we import it into the Terraform state before applying the configuration so that the DNS record points to the new ALB. If the record does not exist, Terraform will create a new DNS record.


.apply-terraform.sh - terraform init and import existing dns record if exists
[source,bash]
----
cd $TERRAFORM_DIR

DNS_NAME=${DNS_NAME:-"servicefoundry.org"}

HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name $DNS_NAME | yq '.HostedZones[0].Id' | awk -F'/' '{print $NF}')

# check if HOSTED_ZONE_ID is 'null'
if [ "$HOSTED_ZONE_ID" == "null" ] || [ -z "$HOSTED_ZONE_ID" ]; then
  echo "Hosted Zone ID for $DNS_NAME not found."
  echo "Please create a hosted zone for $DNS_NAME in Route 53 before applying this Terraform configuration."

  exit 1
else
  echo "Found Hosted Zone ID: $HOSTED_ZONE_ID for $DNS_NAME"
  echo "Using existing hosted zone."

  terraform init

  # check if the DNS record exists
  RECORD_SETS=$(aws route53 list-resource-record-sets \
                  --hosted-zone-id $HOSTED_ZONE_ID \
                  --output yaml \
                  --query "ResourceRecordSets[?Name == '${DNS_NAME}.' && Type == 'A']")

  if [ "$RECORD_SETS" == "[]" ]; then
    echo "DNS record for $DNS_NAME not found in hosted zone $HOSTED_ZONE_ID. It will be created."
  else
    echo "DNS record for $DNS_NAME found in hosted zone $HOSTED_ZONE_ID. Importing into Terraform state."

    DNS_ALIAS="${HOSTED_ZONE_ID}_${DNS_NAME}_A"

    echo "terraform import aws_route53_record.a_alias $DNS_ALIAS"
    terraform import module.alias_for_traefik.aws_route53_record.a_alias $DNS_ALIAS
  fi

  terraform apply --auto-approve
fi

cd $CWD
----


== Terraform Configuration

The Terraform configuration consists of a main configuration file and a module that creates the Route 53 alias record pointing to the ALB created by the AWS Load Balancer Controller.

.terraform directory structure
[source,shell]
----
$ tree terraform
terraform
├── main.tf
└── modules
    └── route53-alias-for-k8s-lb
        ├── main.tf
        └── variables.tf
----

=== main.tf

The `main.tf` file contains the Terraform configuration that defines the AWS and Kubernetes providers, as well as the module to create the Route 53 alias record for the Traefik Load Balancer.

./terraform/main.tf
[source,terraform]
----
provider "aws" {
  region = "ca-central-1"
}

provider "kubernetes" {
  config_path = "~/.kube/config"
  # or host/token/cluster_ca_certificate if running in CI
}

module "alias_for_traefik" {
  source           = "./modules/route53-alias-for-k8s-lb"
  zone_name        = "servicefoundry.org"
  record_name      = "@"                     # root apex; use "app" for app.servicefoundry.org
  k8s_namespace    = "traefik"
  k8s_ingress_name = "traefik-alb"
  create_aaaa      = false
}
----

=== modules/route53-alias-for-k8s-lb/main.tf

This file contains the module that creates the Route 53 alias record pointing to the ALB created by the AWS Load Balancer Controller.

./terraform/modules/route53-alias-for-k8s-lb/main.tf
[source,terraform]
----
terraform {
  required_version = ">= 1.5.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 6.19.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.30.0"
    }
    external = {
      source  = "hashicorp/external"
      version = ">= 2.3"
    }
    null = {
      source  = "hashicorp/null"
      version = ">= 3.2"
    }
  }
}

############################
# Discover the AWS LB by controller tag (robust + gives us zone_id)
############################
# The AWS Load Balancer Controller tags LBs with:
#   servicefoundry.org/service-name = "<namespace>/<ingress-name>"
data "aws_lb" "this" {
  # Tag filter works well with controller-managed LBs
  tags = {
    "servicefoundry.org/service-name" = "${var.k8s_namespace}/${var.k8s_ingress_name}"
  }

}

############################
# Route53
############################
data "aws_route53_zone" "this" {
  name         = var.zone_name
  private_zone = false
}

locals {
  fqdn = var.record_name == "@" ? var.zone_name : "${var.record_name}.${var.zone_name}"
}

# A record → ALB/NLB Alias
resource "aws_route53_record" "a_alias" {
  zone_id = data.aws_route53_zone.this.zone_id
  name    = local.fqdn
  type    = "A"

  alias {
    name                   = data.aws_lb.this.dns_name
    zone_id                = data.aws_lb.this.zone_id
    evaluate_target_health = true
  }
}

############################
# Outputs
############################
output "lb_dns_name" {
  value       = data.aws_lb.this.dns_name
  description = "Discovered Load Balancer DNS name."
}


output "record_fqdn" {
  value       = local.fqdn
  description = "The fully-qualified DNS name created in Route53."
}
----

=== modules/route53-alias-for-k8s-lb/variables.tf

This file defines the input variables for the module.

./terraform/modules/route53-alias-for-k8s-lb/variables.tf
[source,terraform]
----
############################
# Variables
############################
variable "zone_name" {
  description = "Hosted zone name (e.g., servicefoundry.org). No trailing dot."
  type        = string
}

variable "record_name" {
  description = "Record label (e.g., '@', 'app', 'traefik')."
  type        = string
  default     = "@"
}

variable "k8s_namespace" {
  description = "Namespace of the Kubernetes Service (exposed by LB Controller)."
  type        = string
}

variable "k8s_ingress_name" {
  description = "Name of the Kubernetes Service."
  type        = string
}

variable "create_aaaa" {
  description = "Also create AAAA (IPv6) alias to the same LB."
  type        = bool
  default     = true
}
----

== Annotations in Ingress Resource

The properties defined in the Terraform module correspond to the annotations set in the Kubernetes Ingress resource managed by the AWS Load Balancer Controller. Ensure that your Ingress resource includes the necessary annotations to create an ALB.

.k8s/alb-traefik/ingress-traefik-alb.yaml
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: traefik-alb
  namespace: traefik
  annotations:
    alb.ingress.kubernetes.io/load-balancer-name: traefik-alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/tags: "servicefoundry.org/service-name=traefik/traefik-alb,servicefoundry.org/provider=service-foundry"
    alb.ingress.kubernetes.io/target-type: instance     # or "ip"
    alb.ingress.kubernetes.io/healthcheck-path: /ping
    alb.ingress.kubernetes.io/healthcheck-port: '31080'
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:aws-region:aws-account-id:certificate/certificate-arn
spec:
  ingressClassName: alb
  ## rules are omitted for brevity
----

The namespace and ingress name specified in the annotations should match the values provided to the Terraform module.

And the tag `servicefoundry.org/service-name` is used by the Terraform module to discover the ALB created by the AWS Load Balancer Controller.

== Applying the Terraform Configuration

To apply the Terraform configuration and update the Route 53 DNS records, run the `apply-terraform.sh` script after deploying the ALB Ingress resource.

[source,shell]
----
$ kubectl apply -f k8s/alb-traefik/ingress-traefik-alb.yaml

$ ./apply-terraform.sh
----

In your deployment pipeline, ensure that the `apply-terraform.sh` script is executed after the ALB Ingress resource is created or updated.
This will automate the DNS updates in Route 53 whenever a new ALB is provisioned.

== Verifying DNS Updates

After running the script, verify that the DNS records in Route 53 have been updated to point to the new ALB. You can do this by checking the Route 53 console or using the `dig` command:

[source,shell]
----
$ dig +short servicefoundry.org

# output should show updated IP addresses corresponding to the new ALB
----

== Conclusion

By following this guide, you have successfully automated the process of updating Route 53 DNS records whenever a new AWS Application Load Balancer is provisioned using Terraform. This automation helps maintain consistent access to your services without manual intervention, ensuring high availability and reliability for your applications.