---
layout: documents
title: Service Foundry Community Edition - Installation Guide
author: Young Gyu Kim
email: credemol@gmail.com
summary: "Service Foundry Community Edition is a self-hosted platform engineering solution that empowers development teams to manage their cloud infrastructure and deployments efficiently using GitOps principles and best practices."
breadcrumb:
  - name: Home
    url: /
  - name: Docs
    url: /documents/
  - name: Service Foundry
    url: /documents/service-foundry/
---

= Service Foundry Community Edition - Installation Guide

:imagesdir: ./images

[.img-wide]
image::service-foundry-intro.png[Service Foundry Introduction]

== Overview

This comprehensive installation guide walks you through deploying Service Foundry Community Edition on Amazon Web Services (AWS). The Community Edition is a self-hosted platform engineering solution that empowers development teams to manage their cloud infrastructure and deployments efficiently using GitOps principles and best practices.

[NOTE]
====
Service Foundry Community Edition is a self-hosted solution where you provide and manage your own infrastructure. Service Foundry will also offer an Enterprise Edition as a fully managed service in the near future, eliminating the need for infrastructure management.
====

== Prerequisites

Before beginning the installation process, ensure you have the following prerequisites in place:

=== Required Accounts and Access

==== AWS Account
The Community Edition is a self-hosted solution that runs on your own Kubernetes infrastructure. You will need:

- An active AWS account with administrative access
- Permissions to create and manage EKS (Elastic Kubernetes Service) clusters
- Access to AWS Certificate Manager (ACM) for SSL/TLS certificates (recommended for production)
- Route 53 access for DNS management (if using custom domains)

==== GitHub Account
A GitHub account is required for:

- Hosting your GitOps repository, which serves as the single source of truth for all cluster configurations
- Storing deployment manifests and application definitions
- Version controlling your infrastructure as code

=== Technical Knowledge

This installation guide assumes familiarity with:

- Kubernetes concepts and kubectl commands
- Git version control and basic repository management
- AWS services, particularly EKS
- Command-line interface (CLI) operations
- Basic understanding of GitOps principles

== Getting Started

=== Accessing the Community Portal

Service Foundry Community Edition is available free of charge with full feature access. To get started, visit:

https://community.servicefoundry.org/

This portal provides:

- Community Edition license generation
- Bootstrap script generation tools
- Documentation and support resources
- Community forums and updates

== Community Edition License

=== Understanding the License Model

The Community Edition license enables you to use the self-hosted Service Foundry Community Edition with the following terms:

- **Duration**: 365 days from the date of issuance
- **Cost**: Completely free with no payment required
- **Features**: Full access to all Service Foundry capabilities
- **Node Limit**: Supports up to 10 Kubernetes nodes
- **Renewal**: Simple renewal process through the community portal
- **License Format**: JSON Web Token (JWT) for secure validation

[IMPORTANT]
====
The license policy may evolve over time. Always check the community portal for the most current license terms and conditions.
====

=== Step 1: Obtaining Your Community Edition License

Follow these steps to generate your license:

1. Navigate to the Service Foundry Community portal: https://community.servicefoundry.org/
2. Click on the *Community License* page or access directly at: https://community.servicefoundry.org/community-license
3. Complete the registration form with accurate information
4. Generate and download your license file (`.txt` format)

[.img-wide]
image::community-edition-license.png[Community Edition License Download Page]

==== License Form Fields

When completing the license request form, provide the following information:

- **Customer Email Address** (Required): Your valid email address for license delivery and notifications
- **Installation ID** (Required): Your Kubernetes cluster name (e.g., `my-sf-cluster`)
- **Edition**: Pre-filled as `community` (non-editable)
- **NBF** (Not Before): Automatically set to today's date (non-editable)
- **EXP** (Expiration): Automatically set to 365 days from today (non-editable)
- **Max Nodes**: Fixed at 10 nodes (non-editable)

==== Generating and Saving Your License

After completing the form:

1. Click the *Generate License* button
2. Your license will appear in the *License (JWT)* field as a long encoded string
3. Use one of these methods to save your license:
   - Click *Copy License* to copy the JWT to your clipboard for immediate use
   - Click *Save License* to download the license as a file for later reference

[.img-wide]
image::community-edition-license-generated.png[Community Edition License Generated]

[TIP]
====
Store your license file securely. You'll need this JWT token during the bootstrap process. Consider saving it in a password manager or secure documentation system.
====

== Bootstrap Scripts Generation

=== Understanding the Bootstrap Process

Service Foundry provides an automated bootstrap solution that streamlines the installation process. The bootstrap script performs the following operations:

1. Installs ArgoCD as your GitOps continuous delivery engine
2. Configures your GitOps repository as the source of truth
3. Deploys all core platform components
4. Sets up networking and ingress configurations
5. Configures authentication and security components

=== Core Components Included

The bootstrap process deploys a comprehensive platform engineering stack:

==== GitOps and Deployment Tools

- **ArgoCD**: GitOps continuous delivery tool that synchronizes your cluster state with Git repository definitions
- **Argo Rollouts**: Advanced deployment controller supporting blue-green and canary deployment strategies

==== Networking and Ingress

- **Traefik**: Modern HTTP reverse proxy and load balancer for routing external traffic to your services
- **Cert-manager**: Automates the management and issuance of TLS certificates

==== Authentication and Security
- **Keycloak**: Open-source identity and access management solution providing SSO capabilities
- **OAuth2 Proxy**: Authentication proxy that integrates with Keycloak for securing applications
- **Sealed Secrets**: Encrypts Kubernetes secrets for safe storage in Git repositories

==== Data Storage
- **PostgreSQL**: Relational database for Service Foundry Community Edition metadata and application data
- **Redis**: In-memory data store for caching and session management

==== Service Foundry Components
- **Service Foundry Builder**: Component for building and managing application deployments
- **Service Foundry Console Backend**: API server providing backend functionality
- **Service Foundry Console Frontend**: Web-based user interface for platform management

==== HTTP Routes for External Access
- **ArgoCD HTTPRoute**: Secured with ArgoCD native authentication (username/password)
- **Argo Rollouts HTTPRoute**: Integrated with Service Foundry SSO via Keycloak

=== HTTPS and TLS Certificates

==== Security Considerations

While Service Foundry can operate without HTTPS, using TLS certificates is strongly recommended for:

- **Production environments**: Protecting sensitive data in transit
- **Compliance requirements**: Meeting security and regulatory standards
- **User trust**: Providing secure browser connections
- **API security**: Ensuring encrypted communication between components

==== AWS Certificate Manager Integration

This guide demonstrates using AWS Certificate Manager (ACM) for TLS certificate management:

- **Automated validation**: ACM handles certificate validation through DNS
- **Automatic renewal**: Certificates are renewed automatically before expiration
- **AWS integration**: Seamless integration with AWS Load Balancer Controller
- **Cost-effective**: No additional charge for certificates used with AWS services

You will also use Route 53 to create DNS records that route traffic to your Service Foundry endpoints.

=== Generating Bootstrap Scripts

==== Access the Bootstrap Generator

1. Visit the Service Foundry Community portal: https://community.servicefoundry.org/
2. Navigate to the *Bootstrap* page or go directly to: https://community.servicefoundry.org/bootstrap-scripts
3. Complete the bootstrap configuration form with your specific requirements
4. Click *Generate Bootstrap Scripts* to create your customized installation package

[.img-wide]
image::service-foundry-bootstrap.png[Service Foundry Bootstrap]

=== Managing Secure Properties

==== Security Best Practices

The bootstrap script supports environment variable overrides for all configuration properties. This approach enhances security by:

- **Separating secrets from code**: Keeping sensitive data out of version control
- **Environment-specific values**: Using different credentials per environment
- **Reduced exposure**: Minimizing the risk of credential leakage
- **Compliance**: Meeting security audit requirements

==== Implementation Strategy

For secure property management:

1. Leave sensitive fields empty in the bootstrap configuration form
2. Define environment variables before running the bootstrap script
3. The script will automatically use environment variable values when available

**Example**: To override the PostgreSQL password:

[source,shell]
----
export SF_POSTGRES_PASSWORD="your-secure-password"
----

[WARNING]
====
Never commit credentials directly in configuration files. Always use environment variables or secret management solutions for production deployments.
====

=== Bootstrap Configuration Properties

==== Component Versions

Control which versions of Service Foundry components to install:

- **Service Foundry Console Helm Version**: Leave at the default value for the latest stable release
- **Service Foundry Console Application Version**: Keep empty to automatically use the most recent version, or specify a version for reproducible deployments
- **Service Foundry Builder Helm Version**: Use the default version unless you have specific version requirements

[NOTE]
====
Using default versions ensures you receive the latest features and security updates. Specify versions explicitly only when you need version pinning for stability or compatibility reasons.
====

==== Cloud Provider Configuration

Currently, Service Foundry supports AWS exclusively. Future releases may include additional cloud provider support.

**Required Configuration:**

- **Cloud Provider**: AWS (pre-selected)
- **AWS Account ID**: Leave empty to use environment variable `AWS_ACCOUNT_ID`, or enter explicitly
- **AWS Region**: Leave empty to use environment variable `AWS_REGION` (e.g., `us-east-1`), or specify your preferred region
- **Kubernetes Cluster Name**: Enter your EKS cluster name or use environment variable `EKS_CLUSTER_NAME`

[TIP]
====
Using environment variables for AWS credentials and region provides flexibility when working across multiple environments or automating deployments.
====

==== Core Configuration

These settings define fundamental aspects of your Service Foundry installation:

- **Service Foundry Namespace**: The Kubernetes namespace for platform components (default: `service-foundry`)
- **GitOps Repo URL**: SSH or HTTPS URL of your GitOps repository (mandatory) - this will be your single source of truth
- **GitOps User Email**: Email address for Git commits made by Service Foundry (optional, but recommended for audit trails)
- **GitOps User Name**: Name for Git commits (optional, defaults to "service-foundry")
- **Root Domain**: Your base domain for all Service Foundry endpoints (mandatory, e.g., `example.com` or `servicefoundry.org`)
- **Log Level**: Logging verbosity (default: `INFO`, options: `DEBUG`, `INFO`, `WARN`, `ERROR`)

**Example Configuration:**

For this guide, we'll use:

- **GitOps Repo URL**: `git@github.com:nsalexamy/gitops-demo.git`
- **Root Domain**: `servicefoundry.org`

All Service Foundry services will be accessible as subdomains of your root domain:

- `console.servicefoundry.org`
- `argocd.servicefoundry.org`
- `keycloak.servicefoundry.org`

[IMPORTANT]
====
Ensure you have configured an ACM certificate that covers your root domain and all required subdomains, either using a wildcard certificate (`*.servicefoundry.org`) or individual certificates for each subdomain.
====

==== Load Balancer and TLS Configuration

Configure Traefik ingress controller and TLS settings:

- **Use TLS** (env: `TRAEFIK_USE_TLS`): Enable TLS encryption (recommended: `true`)
- **Use AWS ACM** (env: `TRAEFIK_USE_AWS_ACM`): Use AWS Certificate Manager for certificate management (recommended: `true`)
- **ACM Certificate ARN**: The Amazon Resource Name (ARN) of your ACM certificate (mandatory when AWS ACM is enabled)

**Configuration Steps:**

1. Set *Use TLS* to `true`
2. Set *Use AWS ACM* to `true`
3. Paste your ACM certificate ARN in the *ACM Certificate ARN* field

The ARN format looks like: `arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012`

[NOTE]
====
You can find your certificate ARN in the AWS Certificate Manager console. Ensure the certificate is in the same region as your EKS cluster and covers all required domains.
====

==== Credentials Configuration

Define authentication credentials for platform components:

- **PostgreSQL Username**: Database admin username (default: `admin`)
- **PostgreSQL Password**: Secure password for PostgreSQL (use environment variable `SF_POSTGRES_PASSWORD`)
- **Redis Password**: Secure password for Redis (use environment variable `SF_REDIS_PASSWORD`)
- **Service Foundry Admin Console Username**: Initial admin username (default: `admin`)
- **Service Foundry Admin Console Password**: Initial admin password (use environment variable `SF_ADMIN_PASSWORD`)

**Security Recommendation:**

Leave credential fields empty in the form and set them via environment variables:

[source,shell]
----
export SF_POSTGRES_PASSWORD="your-secure-postgres-password"
export SF_REDIS_PASSWORD="your-secure-redis-password"
export SF_ADMIN_PASSWORD="your-secure-admin-password"
----

[CAUTION]
====
Use strong, randomly generated passwords for all credentials. Avoid using default or simple passwords in any environment. Consider using a password manager to generate and store these credentials securely.
====

==== License Configuration

- **License Payload**: Paste your complete Community Edition license JWT obtained from the previous step (mandatory)

This license validates your Service Foundry installation and enables all Community Edition features.

=== Downloading Bootstrap Scripts

After completing all configuration fields:

1. Review your settings for accuracy
2. Click the *Download Bootstrap Scripts* button
3. A ZIP file containing your customized bootstrap scripts will be downloaded
4. Extract the ZIP file to access the installation scripts

[.img-wide]
image::service-foundry-bootstrap-zip.png[Service Foundry Bootstrap Scripts - Zip File]

The downloaded package includes:
- Main bootstrap script (`bootstrap.sh`)
- AWS-specific scripts for EKS cluster creation
- Configuration files pre-filled with your inputs
- Helper scripts for common tasks

== AWS CloudShell Setup

=== Why Use AWS CloudShell?

AWS CloudShell provides an ideal environment for running Service Foundry bootstrap scripts because it offers:

- **Pre-configured AWS credentials**: Automatic authentication with your AWS account
- **Pre-installed tools**: AWS CLI, kubectl, and other essential tools
- **Persistent storage**: 1GB of home directory storage that persists across sessions
- **Browser-based access**: No need to configure local development environment
- **Security**: Runs within AWS network with appropriate IAM permissions

=== Learning Resources

For detailed guidance on using AWS CloudShell effectively, refer to these resources:

- https://youtu.be/9qyVR5EEIes[Deploy Kubernetes Workloads with AWS Cloud Shell + Helm] - Video tutorial demonstrating Kubernetes deployments
- https://nsalexamy.github.io/service-foundry/pages/documents/blog/aws-cloud-shell/persist-custom-software-installations.html#install-eksctl[AWS CloudShell - Persist Custom Software Installations] - Guide for installing and persisting additional tools

=== Additional Tools Required

While AWS CloudShell comes with many tools pre-installed, the Service Foundry bootstrap process requires several additional command-line utilities. These tools must be installed and available in your PATH before running the bootstrap scripts.

==== Required Tools

**eksctl**  
The official CLI tool for creating and managing Amazon EKS clusters. This tool is essential for creating your Kubernetes cluster on AWS with best-practice configurations.

**yq**  
A lightweight and portable command-line YAML processor. The bootstrap scripts use `yq` to parse and update YAML configuration files during the installation process.

**Helm**  
The package manager for Kubernetes. Helm is used to install and manage all Service Foundry components and their dependencies.

==== Installing Required Tools

You can install these tools in AWS CloudShell using the persistent installation method described in the learning resources above. For detailed step-by-step installation instructions, refer to:

https://nsalexamy.github.io/service-foundry/pages/documents/blog/aws-cloud-shell/persist-custom-software-installations.html[AWS CloudShell - Persist Custom Software Installations]

This guide demonstrates how to:

- Install `eksctl` and make it persist across CloudShell sessions
- Install `yq` for YAML processing
- Configure Helm in your CloudShell environment

[TIP]
====
The installations need to be configured to persist across AWS CloudShell sessions. The referenced guide shows you how to use the `$HOME` directory to ensure tools remain available after your CloudShell session expires.
====

=== Preparing Your CloudShell Environment

The default AWS CloudShell home directory is `/home/cloudshell-user`. For organizational purposes, create a dedicated directory for Service Foundry:

[source,shell]
----
# Create a dedicated directory for Service Foundry installation files
$ mkdir -p $HOME/service-foundry

# Navigate to the new directory
$ cd $HOME/service-foundry
----

This directory structure keeps your Service Foundry installation organized and separate from other CloudShell activities.

== GitOps Repository Setup

=== Understanding GitOps Principles

GitOps is a modern approach to infrastructure and application management where:

- **Git as single source of truth**: All configuration is version-controlled in Git
- **Declarative infrastructure**: Desired state is declared in Git repositories
- **Automated synchronization**: Changes in Git trigger automatic cluster updates
- **Audit trail**: Complete history of all infrastructure changes
- **Rollback capability**: Easy recovery by reverting Git commits

Service Foundry uses ArgoCD to implement GitOps, continuously synchronizing your cluster state with your Git repository.

=== Creating Your GitOps Repository

For this guide, we'll create a private GitHub repository named `gitops-demo`:

**Repository Details:**
- **Repository name**: `gitops-demo`
- **Visibility**: Private (recommended for security)
- **Repository URL**: `https://github.com/your-username/gitops-demo.git`

[IMPORTANT]
====
Replace `your-username` with your actual GitHub username throughout this guide.
====

=== Preparing SSH Deployment Keys

==== Why Use Deployment Keys?

Deployment keys provide secure, repository-specific access with these advantages:

- **Scoped access**: Limit access to a single repository
- **No password**: Use key-based authentication
- **Read/write control**: Grant write access only when needed
- **Revocable**: Easy to remove access without affecting other repositories

==== Generating SSH Key Pair

Execute the following commands in AWS CloudShell or your local Linux/Mac terminal:

[source,shell]
----
# Navigate to the Service Foundry directory
$ cd $HOME/service-foundry

# Create a directory for SSH keys
$ mkdir -p gitops-demo-ssh

# Generate a 4096-bit RSA key pair
# -t rsa: Use RSA algorithm
# -b 4096: 4096-bit key length for enhanced security
# -C: Comment to identify the key
# -f: Output file path
$ ssh-keygen -t rsa -b 4096 -C "devops@example.com" -f ./gitops-demo-ssh/id_rsa

# Display the public key (you'll add this to GitHub)
$ cat ./gitops-demo-ssh/id_rsa.pub 
----

[NOTE]
====
The private key (`id_rsa`) must be kept secure and never committed to version control. The public key (`id_rsa.pub`) will be added to GitHub.
====

=== Adding Deployment Key to GitHub

==== Configuration Steps

1. Copy the entire contents of the public key displayed by the `cat` command
2. Navigate to your repository's deployment key settings: `https://github.com/your-username/gitops-demo/settings/keys/new`
3. Complete the form:
   - **Title**: `gitops-demo-ssh` (or any descriptive name)
   - **Key**: Paste the complete public key content
4. **Important**: Check the *Allow write access* checkbox
   - This enables Service Foundry to commit configuration changes back to the repository
5. Click the *Add key* button to save

[WARNING]
====
Ensure write access is enabled. Service Foundry requires write permission to commit generated configurations and application manifests to your GitOps repository.
====

=== Configuring SSH Key Path

Set an environment variable pointing to your private key:

[source,shell]
----
# Set the SSH key path for GitOps operations
$ export GIT_OPS_REPO_SSH_KEY_PATH=$HOME/service-foundry/gitops-demo-ssh/id_rsa
----

This environment variable will be used by the bootstrap script to authenticate with your GitOps repository.

=== Initializing and Pushing the GitOps Repository

==== Configuring Git Identity

If you haven't configured Git user information in your environment, set it now:

[source,shell]
----
# Configure Git user name if not already set
# The || operator ensures this only runs if no user name is configured
$ git config user.name || git config user.name "service-foundry"

# Configure Git user email if not already set  
$ git config user.email || git config user.email "devops@example.com"
----

[TIP]
====
Replace `devops@example.com` with your actual email address to maintain accurate commit attribution.
====

==== Repository Initialization

Create and initialize your local GitOps repository:

[source,shell]
----
# Navigate to Service Foundry directory
$ cd $HOME/service-foundry

# Create the GitOps repository directory
$ mkdir -p gitops-demo
$ cd gitops-demo

# Configure SSH to use the deployment key
# -i: Specifies the identity file (private key)
# -o IdentitiesOnly=yes: Use only the specified key
# -F /dev/null: Ignore user SSH config file
$ export GIT_SSH_COMMAND="ssh -i $GIT_OPS_REPO_SSH_KEY_PATH -o IdentitiesOnly=yes -F /dev/null"

# Initialize a new Git repository
$ git init

# Rename the default branch to 'main'
$ git branch -M main

# Add your GitHub repository as the remote origin
$ git remote add origin git@github.com:your-username/gitops-demo.git

# Create a .gitignore file to exclude macOS metadata files
$ echo ".DS_Store" >> .gitignore

# Stage all files for commit
$ git add .

# Create the initial commit
$ git commit -m "Initial commit"

# Push to GitHub and set upstream tracking
$ git push -u origin main
----

[NOTE]
====
The `GIT_SSH_COMMAND` configuration ensures Git uses your deployment key instead of your default SSH key, providing repository-specific authentication.
====

After successful execution, your GitOps repository is initialized and ready to receive Service Foundry configurations during the bootstrap process.

== Running Bootstrap Scripts on AWS CloudShell

=== Uploading Bootstrap Scripts

Transfer the downloaded bootstrap scripts to AWS CloudShell:

1. In AWS CloudShell, click the *Actions* menu in the top-right corner
2. Select *Upload File*
3. Choose your downloaded `bootstrap-scripts.zip` file
4. Wait for the upload to complete

The uploaded file will appear in your CloudShell home directory (`/home/cloudshell-user`).

=== Extracting Bootstrap Scripts

Move and extract the bootstrap scripts to your Service Foundry directory:

[source,shell]
----
# Move the ZIP file to the Service Foundry directory
$ mv $HOME/bootstrap-scripts.zip $HOME/service-foundry/

# Navigate to the directory
$ cd $HOME/service-foundry

# Extract the ZIP file contents
$ unzip bootstrap-scripts.zip
----

This creates a directory structure containing:
- `bootstrap.sh`: Main installation script
- `aws/`: AWS-specific utilities including EKS cluster creation
- Configuration files with your pre-filled settings

=== Creating a New EKS Cluster (Optional)

==== When to Create a New Cluster

Skip this section if:

- You already have an EKS cluster ready for Service Foundry
- You're installing on an existing development or testing cluster

Proceed with cluster creation if:

- This is a fresh Service Foundry installation
- You want a dedicated cluster for platform engineering

==== Understanding the EKS Creation Script

The included `create-eks.sh` script automates EKS cluster provisioning with:

- **Cluster autoscaler**: Automatically adjusts node count based on workload demands
- **EBS CSI driver**: Enables persistent volume provisioning using Amazon EBS
- **Priority classes**: Configures pod priority for critical system components
- **Best practices**: Implements AWS-recommended EKS configurations

==== Cluster Creation Steps

[source,shell]
----
# Retrieve your AWS account ID automatically
$ export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

# Set your desired cluster name
$ export EKS_CLUSTER_NAME=nsa2-sf 

# Navigate to the AWS scripts directory
$ cd $HOME/service-foundry/aws

# Make all scripts executable
$ chmod +x *.sh

# Execute the EKS cluster creation script
$ ./create-eks.sh
----

[NOTE]
====
The AWS region is automatically detected from your CloudShell session. The cluster will be created in your CloudShell's current region.
====

==== Expected Duration

EKS cluster creation typically takes 10-15 minutes. The script will:

1. Create the EKS control plane
2. Provision managed node groups
3. Install cluster autoscaler
4. Configure EBS CSI driver
5. Set up priority classes
6. Configure kubectl context

You can monitor progress in the CloudShell output. Wait for the script to complete before proceeding.

=== Executing the Bootstrap Script

After your EKS cluster is ready (either newly created or pre-existing), run the main bootstrap script:

[source,shell]
----
# Navigate to the Service Foundry directory
$ cd $HOME/service-foundry

# Make the bootstrap script executable
$ chmod +x *.sh

# Execute the bootstrap script
$ ./bootstrap.sh
----

==== What Happens During Bootstrap

The bootstrap script performs these operations in sequence:

1. **Validates prerequisites**: Checks for required tools and credentials
2. **Configures kubectl**: Sets up cluster access
3. **Installs ArgoCD**: Deploys the GitOps engine
4. **Creates namespaces**: Sets up organizational boundaries
5. **Deploys core components**: Installs all platform services
6. **Configures networking**: Sets up ingress routes
7. **Applies secrets**: Securely configures credentials
8. **Syncs with GitOps repo**: Commits initial configurations to Git
9. **Waits for readiness**: Ensures all components reach a healthy state

[TIP]
====
The bootstrap script provides detailed output. Monitor the logs to track progress and identify any issues that may require attention.
====

==== Troubleshooting

If the bootstrap script encounters errors:

1. Review the error messages carefully
2. Check that all environment variables are set correctly
3. Verify your GitOps repository is accessible
4. Ensure your license is valid and correctly pasted
5. Confirm your EKS cluster has sufficient resources

You can safely re-run the bootstrap script after correcting issuesâ€”it's designed to be idempotent.

== Verifying Installation

=== Post-Installation Checks

After the bootstrap script completes successfully, verify your Service Foundry installation by accessing the deployed components.

=== Accessing Service Foundry Endpoints

Based on your configured root domain, you can access these services:

==== Service Foundry Console
- **URL**: `https://console.your-root-domain`
- **Purpose**: Main Service Foundry user interface for managing applications and deployments
- **Authentication**: Use the admin username and password configured during bootstrap

==== ArgoCD
- **URL**: `https://argocd.your-root-domain`
- **Purpose**: GitOps continuous delivery dashboard
- **Authentication**: Use the ArgoCD admin credentials
  - Username: `admin`
  - Password: Retrieved via: `kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d`

==== Argo Rollouts
- **URL**: `https://argo-rollouts.your-root-domain`
- **Purpose**: Progressive delivery dashboard for visualizing canary and blue-green deployments
- **Authentication**: Integrated with Service Foundry SSO (use your admin credentials)

==== Keycloak
- **URL**: `https://keycloak.your-root-domain`
- **Purpose**: Identity and access management console
- **Authentication**: Admin credentials configured during bootstrap

[IMPORTANT]
====
Replace `your-root-domain` with your actual configured domain (e.g., `servicefoundry.org`). Ensure DNS records are properly configured to route traffic to your cluster's load balancer.
====

=== DNS Configuration Verification

Verify that DNS records are resolving correctly:

[source,shell]
----
# Check DNS resolution for each endpoint
$ nslookup console.your-root-domain
$ nslookup argocd.your-root-domain
$ nslookup argo-rollouts.your-root-domain
$ nslookup keycloak.your-root-domain
----

All domains should resolve to your AWS load balancer address.

=== Component Health Checks

Verify all components are running correctly:

[source,shell]
----
# Check all pods in the service-foundry namespace
$ kubectl get pods -n service-foundry

# Check ArgoCD components
$ kubectl get pods -n argocd

# Verify all applications are synced in ArgoCD
$ kubectl get applications -n argocd
----

All pods should show `Running` status, and ArgoCD applications should show `Synced` and `Healthy` status.

=== Next Steps

After successful installation verification:

1. **Access the Console**: Log in to the Service Foundry console and explore the interface
2. **Review ArgoCD**: Check that all applications are synchronized and healthy
3. **Configure Teams**: Set up user access and team structures in Keycloak
4. **Deploy Applications**: Start deploying your first applications using Service Foundry
5. **Explore Documentation**: Review additional documentation for advanced features

Congratulations! You have successfully installed Service Foundry Community Edition.


