


= Service Foundry - User Guide

:imagesdir: ./images

// :pdf-theme: theme.yaml
// :stylesdir: ./styles
// :stylesheet: custom.css


[.img-wide]
image::architecture-overview.png[Architecture Overview]

author:: Young Gyu Kim
email:: credemol@gmail.com
'''

== Introduction

Service Foundry is a comprehensive platform designed to streamline the deployment, management, and scaling of applications in a Kubernetes-native environment. It integrates various tools and services to provide a seamless experience for developers and operations teams.

[.img-wide]
image::gitops-driven-kubernetes-platform.png[GitOps-Driven Kubernetes Platform]

Service Foundry leverages GitOps principles, treating Git as the single source of truth for all Kubernetes manifests and configurations. This approach ensures that all changes are version-controlled, traceable, and auditable, enhancing collaboration and reliability.

Service Foundry is designed to handle complex application stacks, including observability and big data solutions. It supports the provisioning of both custom enterprise applications from private registries and open-source software from public registries.

=== Key Components

* *Argo CD*: The GitOps continuous delivery tool that will manage the deployment of applications.
* *SealedSecrets*: A tool for managing sensitive information securely in Kubernetes.
* *Keycloak*: An identity and access management solution for Single Sign-On (SSO).
* *Traefik*: A dynamic reverse proxy and load balancer for routing traffic to applications.
* *OAuth2 Proxy for SSO*: A reverse proxy that provides authentication using OAuth2.
* *Traefik IngressRoute for SSO*: IngressRoute configuration for routing SSO traffic.
* *Service Foundry Console Backend*: The API layer that integrates Git repositories and Argo CD.
* *Service Foundry Console Frontend*: The web interface for managing and monitoring applications.

== Main Concepts

Single Source of Truth::
  All Kubernetes manifests and configurations are stored in a Git repository, ensuring version control and traceability.
GitOps:: A set of practices that uses Git repositories as the single source of truth for declarative infrastructure and applications.
Argo CD:: A declarative, GitOps continuous delivery tool for Kubernetes that automates the deployment of applications.
Resource Generator:: A CLI tool that generates Kubernetes manifests from templates, simplifying the creation of complex application stacks.
Service Foundry Builder:: A Kubernetes job that runs the Resource Generator and creates Argo CD applications based on the generated manifests. It has all tools and permissions to interact with the Git repository, Argo CD, and the Kubernetes cluster.
Service Foundry Console:: A web-based interface for managing and monitoring applications, providing visibility into the GitOps workflow.

== Why Service Foundry?

* *Readiness*: Provides a ready-to-use platform for deploying and managing applications in Kubernetes.
* *Simplified Application Management*: Provides a unified platform to manage applications, reducing complexity and operational overhead.
* *Collaboration*: Enhances collaboration between developers and operations teams through a GitOps-based workflow.
* *Automation*: Automates the deployment and management of applications, ensuring consistency and reliability.
* *Scalability*: Designed to handle complex application stacks, including observability and big data solutions.
* *Security*: Integrates with tools like SealedSecrets to manage sensitive information securely.
* *Observability*: Built-in support for monitoring and logging tools like Prometheus, Grafana, Loki, and Tempo.
* **Custom and Open-Source Applications**: Supports provisioning of both custom enterprise applications from private registries and open-source software from public registries.
* *Single Sign-On (SSO)*: Integrates with OAuth2 providers for seamless authentication and access control.


== Bootstrapping Service Foundry

All components of Service Foundry are also deployed and managed using GitOps principles. The entire platform can be bootstrapped using a single command, which sets up the necessary infrastructure, tools, and configurations.



To bootstrap the Service Foundry environment, run the following Helm command. This command installs the Service Foundry Builder in the `service-foundry` namespace, which will then generate the required Kubernetes manifests and create Argo CD applications to deploy the platform.
[,terminal]
----
$ helm install service-foundry-builder \
  service-foundry/service-foundry-builder \
  --set command=bootstrap \
  -n service-foundry --create-namespace \
  --version $SF_BUILDER_CHART_VERSION
----

Before running the command, ensure you have set the following environment variables. These variables provide the necessary configuration for the bootstrapping process.

Here is an example of setting the environment variables for GitOps repository access and configuration:

[,terminal]
----
GIT_OPS_REPO_URL=${GIT_OPS_REPO_URL:-"git@github.com:nsalexamy/service-foundry-argocd.git"}
GIT_OPS_REPO_NAME=${GIT_OPS_REPO_NAME:-"service-foundry-argocd"}
GIT_OPS_REPO_SSH_KEY_PATH=${GIT_OPS_REPO_SSH_KEY_PATH:-"./ssh/argocd-ssh/argocd_id_rsa"}
----

The Service Foundry Builder job will start running and perform the bootstrapping process. You can monitor the progress of the job using the following command:

[,terminal]
----
$ kubectl -n service-foundry get job
NAME                      STATUS    COMPLETIONS   DURATION   AGE
service-foundry-builder   Running   0/1           11s        11s
----

Once the job is complete, it will have set up all the necessary components of the Service Foundry platform, including Argo CD, Keycloak, Traefik, SealedSecrets, and the Service Foundry Console.



=== Service Foundry Console Access

By default, the Service Foundry Console is accessible via the following URL: sfapp.{your-root-domain}. Ensure that your DNS is configured to point to the Traefik load balancer.

After the bootstrapping process is complete, you can access the Service Foundry Console to manage and monitor your applications.

[.img-medium]
image::bootstrap-service-foundry-console-login.png[Service Foundry Console Login]

In Keycloak, there are predefined users created for accessing the Service Foundry Console. The default users are:

* devops (role: admin)
* nick (role: admin)
* sarah (role: user)

// In keycloak, there are users created for accessing the Service Foundry Console. The default users are:

// * Username: 'devops', Password: 'password' (role: admin)
// * Username: 'nick, Password: 'password' (role: admin)
// * Username: 'sarah', Password: 'password' (role: user)


[.img-wide]
image::bootstrap-service-foundry-console.png[Service Foundry Console Access]

In the 'Managed Applications' section, you can view all Argo CD applications deployed in the cluster, created during the bootstrapping process.

=== Git Repository

All components and configurations of the Service Foundry platform are stored in the GitOps repository. The structure of the repository after bootstrapping is as follows:

[.img-wide]
image::bootstrap-git-repository.png[]

// [source,tree]
// ----
// ðŸ“‚ {project-code}-apps
//     ðŸ“‚ {component-name}
//         ðŸ“‚ {project-code}-{release-name}-{version}-helm-app
//         ðŸ“‚ {project-code}-{release-name}-{version}-kustomize-app
//         ðŸ“„ {project-code}-{release-name}-{version}-helm-app.yaml
//         ðŸ“„ {project-code}-{release-name}-{version}-kustomize-app.yaml
// ----

Users can manage GitOps files via the Service Foundry Console or directly through Git operations (clone, commit, push, pull) using Git clients.


=== SealedSecrets applied after Bootstrapping

All sensitive information, such as passwords and API keys, are stored securely using SealedSecrets. After the bootstrapping process, you can view the SealedSecrets in the `service-foundry` namespace.

[.img-wide]
image::bootstrap-git-sealedsecrets.png[SealedSecrets after Bootstrapping]

admin-password is encrypted and stored as a SealedSecret in the GitOps repository. It is used for the initial admin login to the Service Foundry Console.

=== Argo CD Applications after Bootstrapping

All components of the Service Foundry platform are deployed and managed using Argo CD. After the bootstrapping process, you can view the Argo CD applications in the Argo CD UI.

[.img-wide]
image::bootstrap-argocd-applications.png[Argo CD Applications after Bootstrapping]

The GitOps Repository is configured in Argo CD Settings as a repository, allowing Argo CD to sync the applications defined in the repository to the Kubernetes cluster.

[.img-wide]
image::bootstrap-argocd-repositories.png[Argo CD Repositories after Bootstrapping]

By default, 'service-foundry' project is created in Argo CD to manage all applications related to the Service Foundry platform.

[.img-wide]
image::bootstrap-argocd-projects.png[][Argo CD Projects after Bootstrapping]

== Service Foundry Console Features

The Service Foundry Console provides a user-friendly interface for managing and monitoring applications deployed in the Kubernetes cluster.

Main features of the console include:

GitOps::

* *Managed Applications*: View and manage all Argo CD applications deployed in the cluster.
* *Enterprise Applications*: Install and manage custom enterprise applications from private registries.
* *Open Source Software*: Install and manage open-source software applications using Helm and GitOps.
* *GitOps Applications*: View, edit, and delete raw GitOps applications directly.

Kubernetes Stack Orchestration::

* *Framework Core*: View and manage essential services installed during the initial setup.
* *Shared Components*: View and manage cluster-wide services used across multiple stacks.
* *Observability Stack*: Deploy and manage observability tools like Prometheus, Grafana, Loki, and Tempo.
* *Single Sign-On (SSO)*: Manage SSO configurations and user access.
* *Big Data Stack*: Deploy and manage big data solutions like Apache Spark, Airflow, OpenSearch, and Neo4j.
* *Spring Backend Stack*: Deploy and manage Spring Boot applications and related services.

Settings::

* *Configuration*: Manage global settings for the Service Foundry Console.


== Managed Applications

View and manage all Argo CD applications deployed in the cluster. Users can uninstall applications directly from the console. If needed, users can update manifest files on the console so that Argo CD can sync the changes to the cluster.


[.img-wide]
image::console-managed-apps.png[Managed Applications]

From the 'Managed Applications' section, users can view the status of all applications, including their health and sync status. Users can also uninstall applications directly from the console.

[cols="2,8"]
|===
| Button | Action

^.^a| image::icons/enterprise-apps-icon.png[opts=inline, width=24]
| Toggle button to filter and view only Enterprise Applications.

^.^a| image::icons/opensource-software-icon.png[opts=inline, width=24]
| Toggle button to filter and view only Open Source Software applications.

^.^a| image:icons/uninstall-icon.png[opts=inline, width=24] Uninstall
| Button to uninstall the selected application from the cluster.

^.^a| image::icons/uninstall-icon.png[opts=inline, width=24]
| Button to uninstall the application of the row.

|===


To view more details about an application, click on the application name. This will open the application details page, where users can see more information about the application, including its manifests, sync status, and health.

=== Application Files

Users can view and edit the manifest files of the application directly on the console. After making changes, users can commit and push the changes to the Git repository.

[.img-wide]
image::console-managed-apps-view-1.png[Application Details]

[cols="1,9"]
|===
^| Button | Action


^.^a| image::icons/collapse-icon.png[opts=inline, width=24] | Collapse the file tree view.

^.^a| image::icons/expand-icon.png[opts=inline, width=24] | Expand the file tree view.

^.^a| image::icons/refresh-icon.png[opts=inline, width=24] | Refresh the file tree view to see the latest state of the manifest files.

^.^a| image::icons/edit-icon.png[opts=inline, width=24]
| Start editing the manifest files of the application directly on the console. After making changes, users can commit and push the changes to the Git repository.

^.^a| image::icons/undo-icon.png[opts=inline, width=24] | Discard changes made to the manifest files and revert to the last synced state.

^.^a| image::icons/save-icon.png[opts=inline, width=24] | Save changes made to the manifest files. This will stage the changes for commit.

^.^a| image::icons/discard-icon.png[opts=inline, width=24] | Discard all unsaved changes made to the manifest files.

^.^a| image::icons/publish-icon.png[opts=inline, width=24] | Commit and push the changes to the Git repository. This will trigger Argo CD to sync the changes to the cluster.

^.^a| image::icons/comment-icon.png[opts=inline, width=24] | Add a commit message when pushing changes to the Git repository.

^.^a| image::icons/text-decrease-icon.png[opts=inline, width=24] | Decrease the font size of the manifest files for better readability.

^.^a| image::icons/text-increase-icon.png[opts=inline, width=24] | Increase the font size of the manifest files for better readability.

|===

=== Details

The Details tab provides an overview of the application, including its name, namespace, project, sync status, health status, and other relevant information.

[.img-wide]
image::console-managed-apps-view-2.png[Application Details - Properties]

=== Resources

The Resources tab displays the Kubernetes resources associated with the application. Users can view the status of each resource and navigate to the resource details.

[.img-wide]
image::console-managed-apps-view-3.png[Application Details - Resources]


== Enterprise Applications

Install and manage custom enterprise applications from private registries. Users can create Kustomize or Helm applications using predefined templates.


[.img-wide]
image::console-enterprise-apps.png[Enterprise Applications]

Click 'Add New Application' to create a new enterprise application. Users can choose between Kustomize and Helm application types.


=== Create Enterprise Application

An enterprise application can be created using either Kustomize or Helm. Users need to provide the following information:

[.img-wide]
image::console-enterprise-apps-create-1.png[Create Enterprise Application]

==== Common Fields

Common fields are used to generate manifest files and Argo CD application files for both Kustomize and Helm applications.

[cols="1,4,1"]
|===
| Field name | Description | example

| Project Code | A unique code representing your project. This code will be used as a prefix for all resources related to this application. | prj1
| Application Name | A unique name for the application. This name will be used as a suffix for all resources related to this application. | myapp
| Namespace | The Kubernetes namespace where the application will be deployed. | prj1-namespace
| Version | Helm chart version or application version | 0.1.0
| Image Registry | The container image registry where the application's Docker images are stored. | ghcr.io
| Image Repository | The container image repository name for the application. | o11y-otel-spring-example
| Image Tag | The tag of the container image to be used for the application. | 0.1.0
| Replica Count | The number of replicas to be deployed for the application. | 2
| Container Port | The port on which the application container will listen. | 8080
| Service Type | The type of Kubernetes service to expose the application. Options include ClusterIP, NodePort, and LoadBalancer. | ClusterIP

|===

==== Kustomize Application Fields

Manifest files and Argo CD application files will be generated using Kustomize templates.

[cols="1,3"]
|===
| Button | Action

| Add Resource | Add additional Kubernetes resources to the Kustomize application, such as Deployment, Service, ConfigMaps, Secrets, or Ingress resources.
| Remove| Remove the selected resource from the Kustomize application.
| Rename | Rename the selected resource in the Kustomize application.
|===

[.img-wide]
image::console-enterprise-apps-create-2.png[Create Enterprise Application - Kustomize]

Service Foundry generates manifest files based on the provided information and selected resources. Users can view and edit the generated files before creating the application.

[.img-wide]

Click 'Create Application' to create the Kustomize application. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

[.img-wide]
image::gitops-enterprise-app-create.png[GitOps Repository - Enterprise Application Created]

The newly created Kustomize application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::console-enterprise-apps-2.png[Enterprise Application Created]

Click on the application name to view its details, including the generated manifest files and associated resources.

[.img-wide]
image::console-enterprise-apps-view.png[Enterprise Application Details]

Manifest files can be edited directly on the console, and changes can be committed and pushed to the Git repository.

== Open Source Software

Open Source Software applications can be installed and managed using Helm charts from public registries. Users can choose from a list of popular open-source tools and deploy them with a few clicks.

[.img-wide]
image::console-oss-apps.png[Open Source Software Applications]

Select an application from the list and click 'Install' to deploy it.

Here is an example of installing the PostgreSQL using Helm.
[.img-wide]
image::console-oss-apps-install.png[Install Open Source Software Application]

Each application has its own set of configurable parameters. Users can customize the deployment by modifying these parameters before installation. For example, when installing PostgreSQL, users can set the PostgreSQL username, password, and database name.

Click 'Install Application' to deploy the application. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

While the installation is in progress, users can see the current Job status on the header section.

[.img-wide]
image::job-status-in-progress.png[Job Status - In Progress]

=== GitOps Repository after Installing Open Source Software

After the installation is complete, the newly created application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::gitops-oss-apps-create.png[GitOps Repository - Open Source Software Application Created]

=== Open Source Software - View Application

Click on the application name to view its details, including the generated manifest files and associated resources.

[.img-wide]
image::console-oss-learnmore.png[Open Source Software Application Details]

Open Source Software applications can be installed in multiple namespaces. Each installation will create a separate Argo CD application with its own set of resources.

Buttons to manage the application:

[cols="1,3"]
|===
| Button | Action

| Helm App | View the Helm application details, including the generated manifest files and associated resources.
| Kustomize App | View the Kustomize application details, including the generated manifest files and associated resources.
| UNINSTALL | Uninstall the Open Source Software application from the cluster. This will remove all associated resources and delete the Argo CD application. But, manifest files will remain in the Git repository.
|===

=== GitOps Applications

View, edit, and delete raw GitOps applications directly. This section supports full lifecycle operations for any manifests stored in the Git repository.

[.img-wide]
image::console-gitops-apps.png[GitOps Applications]

Users can reuse existing manifest files stored in the Git repository to create new applications. Click 'Add New Application' to create a new GitOps application.

*Action icons on the list*:

[cols="1,9"]
|===
| Button | Action

^.^a| image::icons/copy-files-icon.png[opts=inline, width=24] | Copy the ArgoCD application file path to clipboard.
^.^a| image::icons/edit-files-icon.png[opts=inline, width=24] | Edit the ArgoCD application file directly on the console.
^.^a| image::icons/install-icon.png[opts=inline, width=24] | Install the selected application to the cluster. Enabled only if the application is not yet installed.
^.^a| image::icons/uninstall-icon.png[opts=inline, width=24] | Uninstall the selected application from the cluster. Enabled only if the application is already installed.
^.^a| image::icons/discard-icon.png[opts=inline, width=24] | Delete the selected application from the Git repository. This action cannot be undone.
|===

*Buttons on the header section*:

[cols="1,3"]
|===
| Button | Action

^.^a| image:icons/discard-icon.png[opts=inline, width=24] DELETE APPS | Delete the selected applications from the Git repository. This action cannot be undone.
^.^a| image:icons/install-icon.png[opts=inline, width=24] INSTALL APPS | Install the selected applications to the cluster. Enabled only if the applications are not yet installed.
^.^a| image:icons/uninstall-icon.png[opts=inline, width=24] UNINSTALL APPS | Uninstall the selected applications from the cluster. Enabled only if the applications are already installed.
|===

Click on the application name to view its details, including the manifest files and associated resources.

==== GitOps Applications - View Application

Users can view and edit the manifest files of the application directly on the console. After making changes, users can commit and push the changes to the Git repository.

[.img-wide]
image::console-gitops-apps-view.png[GitOps Application Details]

Buttons in the header section:

[cols="2,5"]
|===
| Button | Action

^.^a| image:icons/file-icon.png[opts=inline, width=24] View App Files | View the manifest files of the application.
^.^a| image:icons/install-icon.png[opts=inline, width=24] Create ArgoCD App | Create an Argo CD application to deploy the resources to the cluster. Enabled only if the application is not yet installed.
^.^a| image:icons/uninstall-icon.png[opts=inline, width=24] Uninstall ArgoCD App | Uninstall the application from the cluster. This will remove all associated resources and delete the Argo CD application. Enabled only if the application is already installed.
^.^a| image:icons/discard-icon.png[opts=inline, width=24] DELETE APP | Delete the application from the Git repository. This action cannot be undone.

|===

== Kubernetes Stack Orchestration
For complex workloads, the platform offers predefined orchestration profiles that bundle related components into stacks for easier deployment.

Kubernetes stacks can be deployed as layers, allowing users to build upon existing stacks. For example, the Observability Stack can be deployed on top of the Framework Core and Shared Components stacks.

Stacks can be deployed in any order, and users can choose to deploy only the stacks they need.

=== Framework Core

Framework Core includes essential services that are installed during the initial setup of Service Foundry. These services provide the foundational components required for the platform to function effectively.

[.img-wide]
image::sf-framework-core.png[Framework Core]

Users can view the configuration details of each component in the Framework Core stack and update settings if necessary. However, it is not recommended to uninstall any components from this stack, as they are critical for the platform's operation.

=== Shared Components
Shared Components include cluster-wide services that are used across multiple stacks. These components provide common functionalities that can be leveraged by various applications and services deployed in the cluster. Kubernetes Operators like prometheus-operator, opentelemetry-operator, and spark-operator are included in this stack.

None of the components in this stack are mandatory, and users can choose to install and uninstall any components they need or do not need.

For example, if you plan to deploy the Observability Stack, you need to install the prometheus-operator and opentelemetry-operator from this stack first.

[.img-wide]
image::sf-shared-components.png[Shared Components]

Click 'Orchestrate' to deploy the Shared Components stack. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

[.img-wide]
image::sf-shared-components-deploy.png[Deploy Shared Components]

Service Foundry will generate the manifest files based on the selected components and deploy them to the cluster. Users can modify the configuration of each component before deployment.

Applicable Domain:

* *Observability*: Cert-manager, Prometheus-operator, Opentelemetry-operator
* *Big Data*: Cert-manager, Spark-operator

Click 'Deploy' to deploy the selected components. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

In the GitOps repository, a new directory named `infra-apps` will be created under the project code directory. This directory contains the manifest files for all selected components in the Shared Components stack.
[.img-wide]
image::gitops-shared-components.png[GitOps Repository - Shared Components Deployed]

And the newly created Shared Components application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::console-managed-apps-shared-components.png[Managed Applications - Shared Components]

=== Observability Stack

The Observability Stack supports monitoring, logging, and tracing via a comprehensive set of tools. Users can choose from different profiles based on their needs, such as Dev, Staging, or Production.

Components have dependencies on each other, so the order of installation matters. For example, if you plan to install Otel Collector, you might need to install Tempo, Prometheus and Loki together.

[.img-wide]
image::sf-observability-stack.png[Observability Stack]

Click 'Orchestrate' to deploy the Observability Stack. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

[.img-wide]
image::sf-observability-stack-deploy.png[Deploy Observability Stack]

There are three profiles available for the Observability Stack:

Dev Profile::
A lightweight setup for development and testing purposes. It includes essential components like Prometheus, Grafana, Loki, and Otel Collector.

Staging Profile::
A more robust setup suitable for staging environments. It includes additional components like OpenSearch and S3 storage for better data management.

Production Profile::
A full-scale observability stack designed for production environments. It includes all components, such as Jaeger, Cassandra, and advanced configurations for scalability and reliability.

Click 'Deploy' to deploy the selected profile. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

In the GitOps repository, a new directory named `observability-apps` will be created under the project code directory. This directory contains the manifest files for all components in the Observability Stack.

[.img-wide]
image::gitops-observability-stack.png[GitOps Repository - Observability Stack Deployed]

And the newly created Observability Stack application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::console-managed-apps-observability-stack.png[Managed Applications - Observability Stack]

=== Single Sign-On (SSO) Stack

The Single Sign-On (SSO) Stack provides authentication and access management for the Service Foundry platform. It integrates with Keycloak to offer a seamless SSO experience for users.

[.img-wide]
image::sf-sso-stack.png[Single Sign-On (SSO) Stack]

Oauth2 Proxy and Traefik IngressRoute with its middlewares are included in this stack to facilitate secure access to the Service Foundry Console and other applications.

This stack enables Kubernetes services to be accessed securely using SSO, enhancing the overall security posture of the platform.

==== Single Sign-On (SSO) Deployment

Click 'Orchestrate' to deploy the SSO Stack. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

[.img-wide]
image::sf-sso-stack-deploy.png[Deploy Single Sign-On Stack]

===== SSO Configuration

[.img-wide]
image::sf-sso-stack-deploy-service.png[SSO Configuration]

Oauth2 Proxy Ingress Form
[cols="1,3,1"]
|===
| Field name | Description | Example

| Name | A unique name for the Oauth2 Proxy Ingress resource. This name will be used as a suffix for all resources related to this ingress. | o11y-sso-ingress
| Namespace | The Kubernetes namespace where the Oauth2 Proxy Ingress will be deployed. | o11y
| Service Name | The name of the Kubernetes service that the Oauth2 Proxy Ingress will route traffic to. | grafana
| Port Name | The port name of the service that the Oauth2 Proxy Ingress will route traffic to. | service
| Subdomain | The domain name that will be used to access the service via the Oauth2 | grafana

|===

Subdomain will be used to create the full URL for accessing the service. The format will be `{subdomain}.{your-root-domain}`. Ensure that your DNS is configured to point to the Traefik load balancer.

If the root domain is 'nsa2.com', and the subdomain is 'grafana', the full URL to access Grafana will be `grafana.nsa2.com`.

Click 'Deploy' to deploy the SSO Stack. This will generate the necessary manifest files, commit them to the Git repository, and create an Argo CD application to deploy the resources to the cluster.

[source,shell]
----
$ kubectl -n o11y get ingressroutes o11y-sso-ingress-route -o yaml | yq '.spec'
----

Here is an example of the generated IngressRoute manifest for Grafana:

[source,yaml]
----
entryPoints:
  - web
routes:
  - kind: Rule
    match: Host(`grafana.nsa2.com`)
    middlewares:
      - name: cors-headers
      - name: forward-auth
    services:
      - name: grafana
        port: service
----

==== GitOps Repository after Installing SSO Stack

After the installation is complete, the newly created SSO Stack application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::gitops-sso-stack.png[GitOps Repository - SSO Stack Deployed]

And the newly created SSO Stack application will appear in the 'Managed Applications' section of the Service Foundry Console.

[.img-wide]
image::console-managed-apps-sso.png[Managed Applications - SSO Stack]

==== Resource Servers

Resource Servers are applications that are protected by the SSO Stack. Users can view and manage all Resource Servers in this section.

[.img-wide]
image::sf-sso-resource-servers.png[SSO Resource Servers]

With the same username and password can be used to access the Resource Servers.

[.img-wide]
image::sf-sso-grafana.png[Accessing Grafana with SSO]

=== Spring Backend Stack (WIP)

The Spring Backend Stack provides a comprehensive environment for deploying and managing Spring Boot applications and related services. This stack includes essential components such as PostgreSQL, Redis, RabbitMQ, and more.

=== Big Data Stack (WIP)

The Big Data Stack offers a robust environment for deploying and managing big data solutions. This stack includes components such as Apache Spark, Airflow, OpenSearch, Neo4j, MinIO, and Dbt.





